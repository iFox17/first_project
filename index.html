<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MovieMatch - –í—ã–±–∏—Ä–∞–µ–º —Ñ–∏–ª—å–º –≤–¥–≤–æ–µ–º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg,
                rgba(102, 126, 234, 0.3) 0%,
                rgba(118, 75, 162, 0.3) 25%,
                rgba(233, 30, 99, 0.3) 50%,
                rgba(118, 75, 162, 0.3) 75%,
                rgba(102, 126, 234, 0.3) 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            padding: 30px 0;
        }

        .logo {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.4);
            letter-spacing: 0.5px;
            line-height: 1.2;
        }

        .header p {
            font-size: 16px;
            opacity: 0.9;
            line-height: 1.5;
            letter-spacing: 0.3px;
        }

        .screen {
            display: none;
            flex-direction: column;
            flex: 1;
        }

        .screen.active {
            display: flex;
        }

        /* Setup Screen */
        .setup-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-top: 20px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .setup-section {
            margin-bottom: 30px;
        }

        .setup-section h3 {
            font-size: 18px;
            margin-bottom: 15px;
            opacity: 0.95;
            font-weight: 600;
            letter-spacing: 0.3px;
            line-height: 1.4;
        }

        .slider-container {
            margin-bottom: 10px;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: none;
        }

        .slider-value {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
        }

        .genre-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        @media (min-width: 640px) {
            .genre-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .genre-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid transparent;
            color: #fff;
            padding: 20px 12px;
            min-height: 80px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            font-size: 13px;
            font-weight: 500;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            line-height: 1.3;
        }

        .genre-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-3px) scale(1.03);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        .genre-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .genre-btn.selected {
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            border-color: #fff;
            font-weight: bold;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
            transform: scale(1.05);
        }

        .genre-btn.selected:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-3px) scale(1.08);
        }

        .language-options {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .language-checkbox {
            flex: 1;
            min-width: 140px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid transparent;
            padding: 16px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .language-checkbox:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .language-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #fff;
        }

        .language-checkbox span {
            font-size: 16px;
            font-weight: 500;
            color: #fff;
            user-select: none;
        }

        .language-checkbox input[type="checkbox"]:checked + span {
            font-weight: 600;
        }

        .language-checkbox:has(input:checked) {
            background: rgba(255, 255, 255, 0.95);
            border-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .language-checkbox:has(input:checked) span {
            color: #667eea;
        }

        .btn {
            width: 100%;
            background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);
            color: #667eea;
            border: none;
            padding: 18px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            margin-top: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
            background: linear-gradient(135deg, #fff 0%, #fff 100%);
        }

        .btn:active {
            transform: translateY(-1px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Swipe Screen */
        .session-code {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            margin-bottom: 15px;
        }

        .session-code strong {
            opacity: 0.7;
            font-weight: 600;
        }

        /* Session code on swipe screen - absolute positioning */
        .swipe-screen .session-code {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 10;
            margin-bottom: 0;
        }

        .swipe-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            padding: 20px 0;
        }

        .swipe-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            gap: 15px;
        }

        .selected-genres {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 13px;
        }

        .selected-genres strong {
            display: block;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .genre-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .genre-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 11px;
        }

        .movies-counter {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            text-align: center;
            min-width: 100px;
        }

        .counter-value {
            font-size: 24px;
            font-weight: bold;
            display: block;
        }

        .counter-label {
            font-size: 11px;
            opacity: 0.8;
        }

        .partner-status {
            background: rgba(46, 213, 115, 0.2);
            border: 1px solid rgba(46, 213, 115, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            display: none;
        }

        .partner-status.show {
            display: block;
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 12px;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #764ba2 0%, #e91e63 50%, #667eea 100%);
            border-radius: 10px;
            transition: width 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(233, 30, 99, 0.3);
        }

        .card-stack {
            position: relative;
            width: 100%;
            height: 75vh;
            max-height: 600px;
            margin-bottom: 30px;
        }

        @media (min-width: 640px) and (max-width: 1024px) {
            .card-stack {
                height: 70vh;
            }
        }

        @media (min-width: 1024px) {
            .card-stack {
                height: 600px;
            }
        }

        .movie-card {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #fff;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            cursor: grab;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1),
                        box-shadow 0.3s ease;
        }

        .movie-card:hover {
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
        }

        .movie-card:active {
            cursor: grabbing;
        }

        .movie-card.swiping {
            transition: none;
        }

        .movie-poster {
            width: 100%;
            height: 65%;
            object-fit: cover;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 100px;
            position: relative;
        }

        .movie-poster img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: top; /* Show top of poster, not center */
        }

        .poster-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .poster-emoji {
            font-size: 80px;
            margin-bottom: 20px;
        }

        .poster-title {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            max-width: 90%;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .movie-rating {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            color: #ffd700;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .language-badges {
            position: absolute;
            bottom: 12px;
            left: 12px;
            display: flex;
            gap: 6px;
        }

        .language-badge {
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(6px);
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .language-badge.rus {
            background: rgba(33, 150, 243, 0.9);
        }

        .language-badge.eng {
            background: rgba(244, 67, 54, 0.9);
        }

        /* Content type badge (movie/series) */
        .content-type-badge {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .content-type-badge.movie {
            background: rgba(103, 58, 183, 0.9);
        }

        .content-type-badge.series {
            background: rgba(233, 30, 99, 0.9);
        }

        .movie-info {
            padding: 16px;
            color: #333;
            height: 35%;
            overflow-y: auto;
        }

        .movie-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 8px;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .movie-meta {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #888;
            flex-wrap: wrap;
        }

        .movie-meta span {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .movie-genres {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .movie-genre {
            background: #667eea;
            color: #fff;
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 11px;
        }

        .movie-description {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .swipe-buttons {
            display: flex;
            justify-content: center;
            gap: 40px;
        }

        .swipe-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            font-size: 36px;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.4, 0.0, 0.2, 1),
                        box-shadow 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        .swipe-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
        }

        .swipe-btn:active {
            transform: scale(0.95);
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.2);
        }

        .dislike-btn {
            background: #ff4757;
        }

        .like-btn {
            background: #2ed573;
        }

        .swipe-indicator {
            position: absolute;
            top: 50%;
            transform: translateY(-50%) scale(0.8);
            font-size: 80px;
            font-weight: bold;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            pointer-events: none;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .swipe-indicator.left {
            left: 30px;
            color: #ff4757;
        }

        .swipe-indicator.right {
            right: 30px;
            color: #2ed573;
        }

        .swipe-indicator.visible {
            opacity: 0.9;
            transform: translateY(-50%) scale(1);
        }

        /* Results Screen */
        .results-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .results-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .results-header h2 {
            font-size: 28px;
            margin-bottom: 10px;
            font-weight: bold;
            letter-spacing: 0.5px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
        }

        .matches-grid {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }

        .match-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            display: flex;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            border: 2px solid transparent;
        }

        .match-card:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .match-card:active {
            transform: translateY(-2px) scale(1);
        }

        .match-poster {
            width: 80px;
            height: 120px;
            border-radius: 10px;
            object-fit: cover;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .match-poster-wrapper {
            position: relative;
            flex-shrink: 0;
        }

        .type-badge-small {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
        }

        .type-badge-small.movie {
            background: rgba(103, 58, 183, 0.9);
        }

        .type-badge-small.series {
            background: rgba(233, 30, 99, 0.9);
        }

        .match-info {
            flex: 1;
        }

        .match-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .match-description {
            font-size: 14px;
            opacity: 0.85;
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            word-wrap: break-word;
        }

        .selection-indicators {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .selection-badge {
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .selection-badge.you {
            background: rgba(46, 213, 115, 0.3);
            border: 2px solid rgba(46, 213, 115, 0.8);
            color: #fff;
        }

        .selection-badge.partner {
            background: rgba(33, 150, 243, 0.3);
            border: 2px solid rgba(33, 150, 243, 0.8);
            color: #fff;
        }

        .match-card.selected-by-you {
            border-color: rgba(46, 213, 115, 0.8);
            box-shadow: 0 0 20px rgba(46, 213, 115, 0.3);
        }

        .confirm-selection-container {
            position: sticky;
            bottom: 20px;
            margin-top: 20px;
            text-align: center;
        }

        .confirm-selection-info {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .waiting-message {
            text-align: center;
            padding: 40px;
            font-size: 18px;
        }

        .loader {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid #fff;
            border-right: 4px solid rgba(233, 30, 99, 0.8);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite,
                       pulse 2s ease-in-out infinite;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        @keyframes spin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .session-info {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .session-link {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
            word-break: break-all;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .session-link:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: scale(1.02);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .session-link:active {
            transform: scale(0.98);
        }

        .final-choice {
            text-align: center;
            padding: 40px;
        }

        .final-movie {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-top: 20px;
        }

        .final-poster {
            width: 100%;
            max-width: 300px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .final-poster-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
        }

        .final-type-badge {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            color: #fff;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .final-type-badge.movie {
            background: rgba(103, 58, 183, 0.9);
        }

        .final-type-badge.series {
            background: rgba(233, 30, 99, 0.9);
        }

        /* Toast Notifications */
        #toastContainer {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
        }

        .toast {
            background: rgba(33, 33, 33, 0.95);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 280px;
            max-width: 400px;
            animation: toastSlideUp 0.3s ease-out;
            pointer-events: auto;
        }

        .toast.success {
            background: rgba(46, 213, 115, 0.95);
        }

        .toast.error {
            background: rgba(255, 71, 87, 0.95);
        }

        .toast.info {
            background: rgba(33, 150, 243, 0.95);
        }

        @keyframes toastSlideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .toast-icon {
            font-size: 20px;
        }

        .toast-message {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
        }

        /* Movie Details Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: #fff;
            border-radius: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
            position: relative;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(0, 0, 0, 1);
            transform: scale(1.1);
        }

        .modal-poster {
            width: 100%;
            height: 400px;
            object-fit: cover;
            border-radius: 20px 20px 0 0;
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .modal-poster img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 20px 20px 0 0;
        }

        .modal-rating {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            color: #ffd700;
            padding: 10px 16px;
            border-radius: 12px;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .modal-languages {
            position: absolute;
            bottom: 15px;
            left: 15px;
            display: flex;
            gap: 8px;
        }

        .modal-language-badge {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            color: #fff;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        }

        .modal-language-badge.rus {
            background: rgba(33, 150, 243, 0.95);
        }

        .modal-language-badge.eng {
            background: rgba(244, 67, 54, 0.95);
        }

        .modal-body {
            padding: 30px;
            color: #333;
        }

        .modal-title {
            font-size: 26px;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
            color: #212121;
        }

        .modal-meta {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #757575;
            flex-wrap: wrap;
        }

        .modal-meta span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .modal-genres {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .modal-genre {
            background: #667eea;
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
        }

        .modal-description {
            font-size: 15px;
            color: #424242;
            line-height: 1.7;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="toastContainer"></div>

    <!-- Movie Details Modal -->
    <div class="modal-overlay" id="movieModal" onclick="closeMovieModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeMovieModal()">‚úï</button>
            <div id="modalMovieDetails"></div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <div class="logo">üé¨</div>
            <h1>MovieMatch</h1>
            <p>–í—ã–±–∏—Ä–∞–µ–º —Ñ–∏–ª—å–º –≤–¥–≤–æ–µ–º</p>
        </div>

        <!-- Setup Screen -->
        <div class="screen active" id="setupScreen">
            <div class="setup-container">
                <div class="setup-section">
                    <h3>–¢–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞</h3>
                    <div class="language-options">
                        <label class="language-checkbox">
                            <input type="checkbox" id="includeMovies" value="movies" checked>
                            <span>üé¨ –§–∏–ª—å–º—ã</span>
                        </label>
                        <label class="language-checkbox">
                            <input type="checkbox" id="includeSeries" value="series">
                            <span>üì∫ –°–µ—Ä–∏–∞–ª—ã</span>
                        </label>
                    </div>
                </div>

                <div class="setup-section">
                    <h3>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ</h3>
                    <div class="slider-container">
                        <input type="range" min="10" max="100" value="20" class="slider" id="movieCountSlider">
                        <div class="slider-value" id="movieCountValue">20</div>
                    </div>
                </div>

                <div class="setup-section">
                    <h3>–í—ã–±–µ—Ä–∏—Ç–µ –∂–∞–Ω—Ä—ã</h3>
                    <div class="genre-grid" id="genreGrid">
                        <!-- Genres will be added dynamically -->
                    </div>
                </div>

                <div class="setup-section">
                    <h3>–°—Ç—Ä–∞–Ω—ã –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞</h3>
                    <div class="genre-grid" id="countryGrid">
                        <!-- Countries will be added dynamically -->
                    </div>
                </div>

                <div class="setup-section">
                    <h3>–Ø–∑—ã–∫–∏ –æ–∑–≤—É—á–∫–∏/—Å—É–±—Ç–∏—Ç—Ä–æ–≤</h3>
                    <div class="language-options">
                        <label class="language-checkbox">
                            <input type="checkbox" id="langRussian" value="rus" checked>
                            <span>üá∑üá∫ –†—É—Å—Å–∫–∏–π</span>
                        </label>
                        <label class="language-checkbox">
                            <input type="checkbox" id="langEnglish" value="eng" checked>
                            <span>üá¨üáß –ê–Ω–≥–ª–∏–π—Å–∫–∏–π</span>
                        </label>
                    </div>
                </div>

                <div class="setup-section">
                    <h3>–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–µ–π—Ç–∏–Ω–≥</h3>
                    <div class="slider-container">
                        <input type="range" min="5.0" max="9.0" step="0.5" value="7.0" class="slider" id="ratingSlider">
                        <div class="slider-value" id="ratingValue">‚≠ê 7.0+</div>
                    </div>
                </div>

                <div class="setup-section">
                    <h3>–ù–µ —Ä–∞–Ω—å—à–µ –∫–∞–∫–æ–≥–æ –≥–æ–¥–∞</h3>
                    <div class="slider-container">
                        <input type="range" min="1970" max="2025" value="2000" class="slider" id="yearSlider">
                        <div class="slider-value" id="yearValue">2000</div>
                    </div>
                </div>

                <button class="btn" id="createSessionBtn">–°–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é</button>
            </div>
        </div>

        <!-- Session Link Screen -->
        <div class="screen" id="linkScreen">
            <div class="session-code" id="sessionCodeLink" style="display: none;">
                <strong>–ö–æ–¥ —Å–µ—Å—Å–∏–∏:</strong> <span id="sessionCodeTextLink"></span>
            </div>
            <div class="session-info">
                <h2>–°–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞!</h2>
                <p>–û—Ç–ø—Ä–∞–≤—å—Ç–µ —ç—Ç—É —Å—Å—ã–ª–∫—É –≤—Ç–æ—Ä–æ–º—É —á–µ–ª–æ–≤–µ–∫—É:</p>
                <div class="session-link" id="sessionLink" onclick="copyLink()">
                    <!-- Link will be generated -->
                </div>
                <p style="margin-top: 15px; font-size: 14px; opacity: 0.8;">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Å—Å—ã–ª–∫—É, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</p>
            </div>
            <div class="waiting-message">
                <div class="loader"></div>
                <p>–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤—Ç–æ—Ä–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞...</p>
            </div>
        </div>

        <!-- Swipe Screen -->
        <div class="screen" id="swipeScreen">
            <div class="session-code" id="sessionCodeDisplay" style="display: none;">
                <strong>–ö–æ–¥:</strong> <span id="sessionCodeText"></span>
            </div>
            <div class="swipe-container">
                <div class="swipe-info">
                    <div class="selected-genres" id="selectedGenresDisplay">
                        <strong>–ñ–∞–Ω—Ä—ã:</strong>
                        <div class="genre-tags" id="genreTags"></div>
                    </div>
                    <div class="movies-counter">
                        <span class="counter-value" id="moviesRemaining">0</span>
                        <span class="counter-label">–æ—Å—Ç–∞–ª–æ—Å—å</span>
                    </div>
                </div>

                <div class="partner-status" id="partnerStatus">
                    ‚úì –ü–∞—Ä—Ç–Ω–µ—Ä –∑–∞–∫–æ–Ω—á–∏–ª –ø—Ä–æ—Å–º–æ—Ç—Ä
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>

                <div class="card-stack" id="cardStack">
                    <div class="swipe-indicator left" id="dislikeIndicator">‚úó</div>
                    <div class="swipe-indicator right" id="likeIndicator">‚ô•</div>
                    <!-- Movie cards will be added dynamically -->
                </div>

                <div class="swipe-buttons">
                    <button class="swipe-btn dislike-btn" onclick="swipe('dislike')">‚úó</button>
                    <button class="swipe-btn like-btn" onclick="swipe('like')">‚ô•</button>
                </div>
            </div>
        </div>

        <!-- Results Screen -->
        <div class="screen" id="resultsScreen">
            <div class="session-code" id="sessionCodeResults" style="display: none;">
                <strong>–ö–æ–¥ —Å–µ—Å—Å–∏–∏:</strong> <span id="sessionCodeTextResults"></span>
            </div>
            <div class="results-container">
                <div class="results-header">
                    <h2>–°–æ–≤–ø–∞–¥–µ–Ω–∏—è!</h2>
                    <p>–í—ã –æ–±–∞ –≤—ã–±—Ä–∞–ª–∏ —ç—Ç–∏ —Ñ–∏–ª—å–º—ã</p>
                </div>
                <div class="matches-grid" id="matchesGrid">
                    <!-- Matches will be added dynamically -->
                </div>
            </div>
        </div>

        <!-- Final Choice Screen -->
        <div class="screen" id="finalScreen">
            <div class="session-code" id="sessionCodeFinal" style="display: none;">
                <strong>–ö–æ–¥ —Å–µ—Å—Å–∏–∏:</strong> <span id="sessionCodeTextFinal"></span>
            </div>
            <div class="final-choice">
                <h2>–í–∞—à –≤—ã–±–æ—Ä:</h2>
                <div class="final-movie" id="finalMovie">
                    <!-- Final movie will be displayed -->
                </div>
                <button class="btn" onclick="startOver()">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
            </div>
        </div>
    </div>

    <script>
        // TMDB API Configuration
        const TMDB_API_KEY = 'fa372a103e830cd8e937e23614f75c39';
        const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
        const TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p/w500';

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBQnA0C5Ouf9pC3El_GXX0_aLAcFaYT2Co",
            authDomain: "filmmatching-8a8bf.firebaseapp.com",
            databaseURL: "https://filmmatching-8a8bf-default-rtdb.firebaseio.com",
            projectId: "filmmatching-8a8bf",
            storageBucket: "filmmatching-8a8bf.firebasestorage.app",
            messagingSenderId: "104378741912",
            appId: "1:104378741912:web:aefae82ff333922aef0ced",
            measurementId: "G-41PV9QGCRM"
        };

        // Initialize Firebase
        let database = null;
        let useFirebase = false;
        let firebaseInitPromise = null;

        // Promise-based Firebase initialization
        if (firebaseConfig.apiKey !== "YOUR_API_KEY") {
            firebaseInitPromise = new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                    reject(new Error('Firebase initialization timeout'));
                }, 15000); // 15 second timeout

                const script1 = document.createElement('script');
                script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
                script1.onerror = () => {
                    clearTimeout(timeoutId);
                    reject(new Error('Failed to load Firebase App SDK'));
                };
                script1.onload = () => {
                    const script2 = document.createElement('script');
                    script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js';
                    script2.onerror = () => {
                        clearTimeout(timeoutId);
                        reject(new Error('Failed to load Firebase Database SDK'));
                    };
                    script2.onload = () => {
                        try {
                            firebase.initializeApp(firebaseConfig);
                            database = firebase.database();
                            useFirebase = true;
                            clearTimeout(timeoutId);
                            console.log('Firebase –ø–æ–¥–∫–ª—é—á–µ–Ω');
                            resolve(database);
                        } catch (error) {
                            clearTimeout(timeoutId);
                            console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Firebase:', error);
                            reject(error);
                        }
                    };
                    document.head.appendChild(script2);
                };
                document.head.appendChild(script1);
            });
        } else {
            console.log('Firebase –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –†–∞–±–æ—Ç–∞–µ—Ç –≤ –¥–µ–º–æ-—Ä–µ–∂–∏–º–µ (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è).');
            firebaseInitPromise = Promise.reject(new Error('Firebase not configured'));
        }

        // Helper to wait for Firebase
        async function waitForFirebase(timeout = 15000) {
            if (!firebaseInitPromise) {
                throw new Error('Firebase not configured');
            }
            try {
                await firebaseInitPromise;
                return database;
            } catch (error) {
                throw error;
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') {
                return unsafe;
            }
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Validate and normalize Firebase session data
        function validateSessionData(sessionData) {
            console.log('[validateSessionData] Validating session data:', JSON.stringify(sessionData, null, 2));

            if (!sessionData || typeof sessionData !== 'object') {
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö —Å–µ—Å—Å–∏–∏');
            }

            // Validate and normalize genres
            console.log('[validateSessionData] Checking genres:', sessionData.genres, 'isArray:', Array.isArray(sessionData.genres));

            // Try to fix if genres is an object that looks like an array
            if (!Array.isArray(sessionData.genres) && typeof sessionData.genres === 'object') {
                console.warn('[validateSessionData] genres is object, attempting to convert to array');
                const keys = Object.keys(sessionData.genres);
                if (keys.every(key => /^\d+$/.test(key))) {
                    sessionData.genres = keys.map(k => sessionData.genres[k]);
                    console.log('[validateSessionData] Converted genres to array:', sessionData.genres);
                }
            }

            if (!Array.isArray(sessionData.genres) || sessionData.genres.length === 0) {
                console.error('[validateSessionData] genres validation failed:', {
                    value: sessionData.genres,
                    isArray: Array.isArray(sessionData.genres),
                    length: sessionData.genres?.length,
                    type: typeof sessionData.genres
                });
                throw new Error('–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–µ –∂–∞–Ω—Ä—ã');
            }

            // Validate all genre IDs are numbers
            console.log('[validateSessionData] Checking genre types:', sessionData.genres.map(id => typeof id));
            const allNumbers = sessionData.genres.every(id => typeof id === 'number');
            if (!allNumbers) {
                console.error('[validateSessionData] Not all genre IDs are numbers:',
                    sessionData.genres.map(id => ({ value: id, type: typeof id })));
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID –∂–∞–Ω—Ä–æ–≤');
            }

            console.log('[validateSessionData] Genres validation passed ‚úì');

            // Validate countries (optional)
            if (sessionData.countries !== undefined && !Array.isArray(sessionData.countries)) {
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Ç—Ä–∞–Ω');
            }

            // Validate movieCount
            if (typeof sessionData.movieCount !== 'number' ||
                sessionData.movieCount < 10 ||
                sessionData.movieCount > 100) {
                throw new Error('–ù–µ–≤–µ—Ä–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∏–ª—å–º–æ–≤ (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 10-100)');
            }

            // Validate minYear
            if (typeof sessionData.minYear !== 'number' ||
                sessionData.minYear < 1970 ||
                sessionData.minYear > 2025) {
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π –≥–æ–¥ (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 1970-2025)');
            }

            return true;
        }

        // Available genres (for movies)
        const genres = [
            { id: 28, name: '–ë–æ–µ–≤–∏–∫' },
            { id: 35, name: '–ö–æ–º–µ–¥–∏—è' },
            { id: 18, name: '–î—Ä–∞–º–∞' },
            { id: 27, name: '–£–∂–∞—Å—ã' },
            { id: 10749, name: '–ú–µ–ª–æ–¥—Ä–∞–º–∞' },
            { id: 878, name: '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞' },
            { id: 53, name: '–¢—Ä–∏–ª–ª–µ—Ä' },
            { id: 16, name: '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º' }
        ];

        // TV genres mapping (TMDB uses different IDs for TV)
        // Maps movie genre IDs to corresponding TV genre IDs
        const tvGenreMapping = {
            28: 10759,   // Action -> Action & Adventure
            35: 35,      // Comedy (same)
            18: 18,      // Drama (same)
            27: 9648,    // Horror -> Mystery (closest match)
            10749: 18,   // Romance -> Drama (romance is not separate in TV)
            878: 10765,  // Sci-Fi -> Sci-Fi & Fantasy
            53: 80,      // Thriller -> Crime (closest match)
            16: 16       // Animation (same)
        };

        // TV genre names for display
        const tvGenres = [
            { id: 10759, name: '–ë–æ–µ–≤–∏–∫ –∏ –ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è' },
            { id: 35, name: '–ö–æ–º–µ–¥–∏—è' },
            { id: 18, name: '–î—Ä–∞–º–∞' },
            { id: 9648, name: '–î–µ—Ç–µ–∫—Ç–∏–≤' },
            { id: 10765, name: '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞' },
            { id: 80, name: '–ö—Ä–∏–º–∏–Ω–∞–ª' },
            { id: 16, name: '–ú—É–ª—å—Ç—Å–µ—Ä–∏–∞–ª' }
        ];

        // Available countries (ISO 3166-1)
        const countries = [
            { code: 'US', name: '–°–®–ê' },
            { code: 'GB', name: '–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è' },
            { code: 'FR', name: '–§—Ä–∞–Ω—Ü–∏—è' },
            { code: 'DE', name: '–ì–µ—Ä–º–∞–Ω–∏—è' },
            { code: 'IT', name: '–ò—Ç–∞–ª–∏—è' },
            { code: 'ES', name: '–ò—Å–ø–∞–Ω–∏—è' },
            { code: 'RU', name: '–†–æ—Å—Å–∏—è' },
            { code: 'JP', name: '–Ø–ø–æ–Ω–∏—è' },
            { code: 'KR', name: '–ö–æ—Ä–µ—è' },
            { code: 'CN', name: '–ö–∏—Ç–∞–π' }
        ];

        // ============================================
        // EMBEDDED MOVIE/SERIES DATABASE (Fallback for TMDB failures)
        // ============================================
        // All poster URLs are from TMDB: https://image.tmdb.org/t/p/w500/{path}
        const embeddedMovies = [
            // === –§–ò–õ–¨–ú–´ (MOVIES) - —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –ø–æ—Å—Ç–µ—Ä–∞–º–∏ TMDB ===
            // Poster URLs: https://image.tmdb.org/t/p/w500/{path}

            // –ë–æ–µ–≤–∏–∫ / –¢—Ä–∏–ª–ª–µ—Ä
            { id: 550, title: '–ë–æ–π—Ü–æ–≤—Å–∫–∏–π –∫–ª—É–±', overview: '–¢–µ—Ä–∑–∞–µ–º—ã–π —Ö—Ä–æ–Ω–∏—á–µ—Å–∫–æ–π –±–µ—Å—Å–æ–Ω–Ω–∏—Ü–µ–π –∫–ª–µ—Ä–∫ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç –¢–∞–π–ª–µ—Ä–∞ –î—ë—Ä–¥–µ–Ω–∞.', poster: 'https://image.tmdb.org/t/p/w500/pB8BM7pdSp6B6Ih7QZ4DrQ3PmJK.jpg', rating: '8.4', year: '1999', director: '–î—ç–≤–∏–¥ –§–∏–Ω—á–µ—Ä', movieGenres: ['–ë–æ–µ–≤–∏–∫', '–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 155, title: '–¢—ë–º–Ω—ã–π —Ä—ã—Ü–∞—Ä—å', overview: '–ë—ç—Ç–º–µ–Ω —Å—Ç–∞–ª–∫–∏–≤–∞–µ—Ç—Å—è —Å –î–∂–æ–∫–µ—Ä–æ–º, —É–≥—Ä–æ–∂–∞—é—â–∏–º –ø–æ–≥—Ä—É–∑–∏—Ç—å –ì–æ—Ç—ç–º –≤ —Ö–∞–æ—Å.', poster: 'https://image.tmdb.org/t/p/w500/qJ2tW6WMUDux911r6m7haRef0WH.jpg', rating: '9.0', year: '2008', director: '–ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä –ù–æ–ª–∞–Ω', movieGenres: ['–ë–æ–µ–≤–∏–∫', '–¢—Ä–∏–ª–ª–µ—Ä'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 27205, title: '–ù–∞—á–∞–ª–æ', overview: '–í–æ—Ä –∫—Ä–∞–¥—ë—Ç —Å–µ–∫—Ä–µ—Ç—ã –∏–∑ –ø–æ–¥—Å–æ–∑–Ω–∞–Ω–∏—è –ª—é–¥–µ–π –≤–æ –≤—Ä–µ–º—è —Å–Ω–∞.', poster: 'https://image.tmdb.org/t/p/w500/edv5CZvWj09upOsy2Y6IwDhK8bt.jpg', rating: '8.8', year: '2010', director: '–ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä –ù–æ–ª–∞–Ω', movieGenres: ['–ë–æ–µ–≤–∏–∫', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 603, title: '–ú–∞—Ç—Ä–∏—Ü–∞', overview: '–•–∞–∫–µ—Ä —É–∑–Ω–∞—ë—Ç, —á—Ç–æ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å ‚Äî —Å–∏–º—É–ª—è—Ü–∏—è, —Å–æ–∑–¥–∞–Ω–Ω–∞—è –º–∞—à–∏–Ω–∞–º–∏.', poster: 'https://image.tmdb.org/t/p/w500/f89U3ADr1oiB1s9GkdPOEpXUk5H.jpg', rating: '8.7', year: '1999', director: '–í–∞—á–æ–≤—Å–∫–∏', movieGenres: ['–ë–æ–µ–≤–∏–∫', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 157336, title: '–ò–Ω—Ç–µ—Ä—Å—Ç–µ–ª–ª–∞—Ä', overview: '–ö–æ–º–∞–Ω–¥–∞ –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Ç–µ—à–µ—Å—Ç–≤—É–µ—Ç —á–µ—Ä–µ–∑ —á–µ—Ä–≤–æ—Ç–æ—á–∏–Ω—É –≤ –ø–æ–∏—Å–∫–∞—Ö –Ω–æ–≤–æ–≥–æ –¥–æ–º–∞.', poster: 'https://image.tmdb.org/t/p/w500/gEU2QniE6E77NI6lCU6MxlNBvIx.jpg', rating: '8.6', year: '2014', director: '–ö—Ä–∏—Å—Ç–æ—Ñ–µ—Ä –ù–æ–ª–∞–Ω', movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 299536, title: '–ú—Å—Ç–∏—Ç–µ–ª–∏: –í–æ–π–Ω–∞ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç–∏', overview: '–¢–∞–Ω–æ—Å —Å–æ–±–∏—Ä–∞–µ—Ç –ö–∞–º–Ω–∏ –ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç–∏, —á—Ç–æ–±—ã —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å –ø–æ–ª–æ–≤–∏–Ω—É –≤—Å–µ–ª–µ–Ω–Ω–æ–π.', poster: 'https://image.tmdb.org/t/p/w500/7WsyChQLEftFiDOVTGkv3hFpyyt.jpg', rating: '8.4', year: '2018', director: '–≠–Ω—Ç–æ–Ω–∏ –†—É—Å—Å–æ', movieGenres: ['–ë–æ–µ–≤–∏–∫', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 299534, title: '–ú—Å—Ç–∏—Ç–µ–ª–∏: –§–∏–Ω–∞–ª', overview: '–ú—Å—Ç–∏—Ç–µ–ª–∏ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è –≤ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑, —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å —â–µ–ª—á–æ–∫ –¢–∞–Ω–æ—Å–∞.', poster: 'https://image.tmdb.org/t/p/w500/or06FN3Dka5tukK1e9sl16pB3iy.jpg', rating: '8.4', year: '2019', director: '–≠–Ω—Ç–æ–Ω–∏ –†—É—Å—Å–æ', movieGenres: ['–ë–æ–µ–≤–∏–∫', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 76341, title: '–ë–µ–∑—É–º–Ω—ã–π –ú–∞–∫—Å: –î–æ—Ä–æ–≥–∞ —è—Ä–æ—Å—Ç–∏', overview: '–í –ø–æ—Å—Ç–∞–ø–æ–∫–∞–ª–∏–ø—Ç–∏—á–µ—Å–∫–æ–π –ø—É—Å—Ç–æ—à–∏ –ú–∞–∫—Å –ø–æ–º–æ–≥–∞–µ—Ç –§—É—Ä–∏–æ—Å–µ —Å–±–µ–∂–∞—Ç—å.', poster: 'https://image.tmdb.org/t/p/w500/8tZYtuWezp8JbcsvHYO0O46tFbo.jpg', rating: '8.1', year: '2015', director: '–î–∂–æ—Ä–¥–∂ –ú–∏–ª–ª–µ—Ä', movieGenres: ['–ë–æ–µ–≤–∏–∫', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 293660, title: '–î—ç–¥–ø—É–ª', overview: '–ë—ã–≤—à–∏–π —Å–ø–µ—Ü–Ω–∞–∑–æ–≤–µ—Ü —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∞–Ω—Ç–∏–≥–µ—Ä–æ–µ–º —Å —Ä–µ–≥–µ–Ω–µ—Ä–∞—Ç–∏–≤–Ω—ã–º–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—è–º–∏.', poster: 'https://image.tmdb.org/t/p/w500/3E53WEZJqP6aM84D8CckXx4pIHw.jpg', rating: '8.0', year: '2016', director: '–¢–∏–º –ú–∏–ª–ª–µ—Ä', movieGenres: ['–ë–æ–µ–≤–∏–∫', '–ö–æ–º–µ–¥–∏—è'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 634649, title: '–ß–µ–ª–æ–≤–µ–∫-–ø–∞—É–∫: –ù–µ—Ç –ø—É—Ç–∏ –¥–æ–º–æ–π', overview: '–ü–∏—Ç–µ—Ä –ü–∞—Ä–∫–µ—Ä –ø—Ä–æ—Å–∏—Ç –î–æ–∫—Ç–æ—Ä–∞ –°—Ç—Ä—ç–Ω–¥–∂–∞ –ø–æ–º–æ—á—å –∑–∞–±—ã—Ç—å –µ–≥–æ –ª–∏—á–Ω–æ—Å—Ç—å.', poster: 'https://image.tmdb.org/t/p/w500/1g0dhYtq4irTY1GPXvft6k4YLjm.jpg', rating: '8.2', year: '2021', director: '–î–∂–æ–Ω –£–æ—Ç—Ç—Å', movieGenres: ['–ë–æ–µ–≤–∏–∫', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 438631, title: '–î—é–Ω–∞', overview: '–ü–æ–ª –ê—Ç—Ä–µ–π–¥–µ—Å –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –Ω–∞ –æ–ø–∞—Å–Ω—É—é –ø–ª–∞–Ω–µ—Ç—É –ê—Ä—Ä–∞–∫–∏—Å.', poster: 'https://image.tmdb.org/t/p/w500/d5NXSklXo0qyIYkgV94XAgMIckC.jpg', rating: '8.0', year: '2021', director: '–î–µ–Ω–∏ –í–∏–ª—å–Ω—ë–≤', movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 766507, title: '–î—é–Ω–∞: –ß–∞—Å—Ç—å –≤—Ç–æ—Ä–∞—è', overview: '–ü–æ–ª –ê—Ç—Ä–µ–π–¥–µ—Å –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç—Å—è —Å –ß–∞–Ω–∏ –∏ —Ñ—Ä–µ–º–µ–Ω–∞–º–∏ –¥–ª—è –º–µ—Å—Ç–∏.', poster: 'https://image.tmdb.org/t/p/w500/8b8R8l88Qje9dn9OE8PY05Nxl1X.jpg', rating: '8.5', year: '2024', director: '–î–µ–Ω–∏ –í–∏–ª—å–Ω—ë–≤', movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–ë–æ–µ–≤–∏–∫'], languages: ['rus', 'eng'], type: 'movie' },

            // –î—Ä–∞–º–∞
            { id: 278, title: '–ü–æ–±–µ–≥ –∏–∑ –®–æ—É—à–µ–Ω–∫–∞', overview: '–ë–∞–Ω–∫–∏—Ä –Ω–µ—Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ –æ—Å—É–∂–¥—ë–Ω –∏ –Ω–∞—Ö–æ–¥–∏—Ç –∏—Å–∫—É–ø–ª–µ–Ω–∏–µ –≤ —Ç—é—Ä—å–º–µ.', poster: 'https://image.tmdb.org/t/p/w500/q6y0Go1tsGEsmtFryDOJo3dEmqu.jpg', rating: '9.3', year: '1994', director: '–§—Ä—ç–Ω–∫ –î–∞—Ä–∞–±–æ–Ω—Ç', movieGenres: ['–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 238, title: '–ö—Ä—ë—Å—Ç–Ω—ã–π –æ—Ç–µ—Ü', overview: '–°—Ç–∞—Ä–µ—é—â–∏–π –ø–∞—Ç—Ä–∏–∞—Ä—Ö –∫—Ä–∏–º–∏–Ω–∞–ª—å–Ω–æ–π –¥–∏–Ω–∞—Å—Ç–∏–∏ –ø–µ—Ä–µ–¥–∞—ë—Ç –∫–æ–Ω—Ç—Ä–æ–ª—å —Å—ã–Ω—É.', poster: 'https://image.tmdb.org/t/p/w500/3bhkrj58Vtu7enYsRolD1fZdja1.jpg', rating: '9.2', year: '1972', director: '–§—Ä—ç–Ω—Å–∏—Å –ö–æ–ø–ø–æ–ª–∞', movieGenres: ['–î—Ä–∞–º–∞', '–¢—Ä–∏–ª–ª–µ—Ä'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 424, title: '–°–ø–∏—Å–æ–∫ –®–∏–Ω–¥–ª–µ—Ä–∞', overview: '–û—Å–∫–∞—Ä –®–∏–Ω–¥–ª–µ—Ä —Å–ø–∞—Å –±–æ–ª–µ–µ —Ç—ã—Å—è—á–∏ –ø–æ–ª—å—Å–∫–∏—Ö –µ–≤—Ä–µ–µ–≤ –≤–æ –≤—Ä–µ–º—è –•–æ–ª–æ–∫–æ—Å—Ç–∞.', poster: 'https://image.tmdb.org/t/p/w500/sF1U4EUQS8YHUYjNl3pMGNIQyr0.jpg', rating: '9.0', year: '1993', director: '–°—Ç–∏–≤–µ–Ω –°–ø–∏–ª–±–µ—Ä–≥', movieGenres: ['–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 497, title: '–ó–µ–ª—ë–Ω–∞—è –º–∏–ª—è', overview: '–û—Ö—Ä–∞–Ω–Ω–∏–∫ –∫–∞–º–µ—Ä—ã —Å–º–µ—Ä—Ç–Ω–∏–∫–æ–≤ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç —á—É–¥–µ—Å–Ω—ã–π –¥–∞—Ä —É –∑–∞–∫–ª—é—á—ë–Ω–Ω–æ–≥–æ.', poster: 'https://image.tmdb.org/t/p/w500/velWPhVMQeQKcxggNEU8YmIo52R.jpg', rating: '8.6', year: '1999', director: '–§—Ä—ç–Ω–∫ –î–∞—Ä–∞–±–æ–Ω—Ç', movieGenres: ['–î—Ä–∞–º–∞', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 13, title: '–§–æ—Ä—Ä–µ—Å—Ç –ì–∞–º–ø', overview: '–ü—Ä–æ—Å—Ç–æ–¥—É—à–Ω—ã–π —á–µ–ª–æ–≤–µ–∫ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–≤–∏–¥–µ—Ç–µ–ª–µ–º –∫–ª—é—á–µ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π –∏—Å—Ç–æ—Ä–∏–∏.', poster: 'https://image.tmdb.org/t/p/w500/arw2vcBveWOVZr6pxd9XTd1TdQa.jpg', rating: '8.8', year: '1994', director: '–†–æ–±–µ—Ä—Ç –ó–µ–º–µ–∫–∏—Å', movieGenres: ['–î—Ä–∞–º–∞', '–ö–æ–º–µ–¥–∏—è'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 496243, title: '–ü–∞—Ä–∞–∑–∏—Ç—ã', overview: '–ë–µ–¥–Ω–∞—è —Å–µ–º—å—è –ø—Ä–æ–Ω–∏–∫–∞–µ—Ç –≤ –¥–æ–º –±–æ–≥–∞—Ç–æ–π —Å–µ–º—å–∏.', poster: 'https://image.tmdb.org/t/p/w500/7IiTTgloJzvGI1TAYymCfbfl3vT.jpg', rating: '8.5', year: '2019', director: '–ü–æ–Ω –î–∂—É–Ω-—Ö–æ', movieGenres: ['–î—Ä–∞–º–∞', '–¢—Ä–∏–ª–ª–µ—Ä'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 244786, title: '–û–¥–µ—Ä–∂–∏–º–æ—Å—Ç—å', overview: '–ë–∞—Ä–∞–±–∞–Ω—â–∏–∫ —Å—Ç—Ä–µ–º–∏—Ç—Å—è –∫ —Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤—É –ø–æ–¥ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ–º –∂–µ—Å—Ç–æ–∫–æ–≥–æ –Ω–∞—Å—Ç–∞–≤–Ω–∏–∫–∞.', poster: 'https://image.tmdb.org/t/p/w500/6uSPi9YaKoqYl1i3jYFy3hLBuNi.jpg', rating: '8.5', year: '2014', director: '–î—ç–º—å–µ–Ω –®–∞–∑–µ–ª–ª', movieGenres: ['–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'movie' },

            // –ö–æ–º–µ–¥–∏—è / –ú—É–ª—å—Ç—Ñ–∏–ª—å–º
            { id: 862, title: '–ò—Å—Ç–æ—Ä–∏—è –∏–≥—Ä—É—à–µ–∫', overview: '–ò–≥—Ä—É—à–∫–∏ –æ–∂–∏–≤–∞—é—Ç, –∫–æ–≥–¥–∞ –ª—é–¥–µ–π –Ω–µ—Ç —Ä—è–¥–æ–º.', poster: 'https://image.tmdb.org/t/p/w500/uXDfjJbdP4ijW5hWSBrPrlKpxab.jpg', rating: '8.3', year: '1995', director: '–î–∂–æ–Ω –õ–∞—Å—Å–µ—Ç–µ—Ä', movieGenres: ['–ö–æ–º–µ–¥–∏—è', '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 354912, title: '–ö–æ–∫–æ', overview: '–ú–∞–ª—å—á–∏–∫ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ –°—Ç—Ä–∞–Ω—É –º—ë—Ä—Ç–≤—ã—Ö, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ —Å–≤–æ–µ–≥–æ –ø—Ä–∞–¥–µ–¥–∞.', poster: 'https://image.tmdb.org/t/p/w500/gGEsBPAijhVUFoiNpgZXqRVWJt2.jpg', rating: '8.4', year: '2017', director: '–õ–∏ –ê–Ω–∫—Ä–∏—á', movieGenres: ['–ö–æ–º–µ–¥–∏—è', '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 508947, title: '–î—É—à–∞', overview: '–£—á–∏—Ç–µ–ª—å –º—É–∑—ã–∫–∏ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ –º–∏—Ä –¥–æ —Ä–æ–∂–¥–µ–Ω–∏—è –¥—É—à.', poster: 'https://image.tmdb.org/t/p/w500/hm58Jw4Lw8OIeECIq5qyPYhAeRJ.jpg', rating: '8.1', year: '2020', director: '–ü–∏—Ç –î–æ–∫—Ç–µ—Ä', movieGenres: ['–ö–æ–º–µ–¥–∏—è', '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 269149, title: '–ó–≤–µ—Ä–æ–ø–æ–ª–∏—Å', overview: '–ö—Ä–æ–ª—å—á–∏—Ö–∞-–∫–æ–ø—à–∞ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –∑–∞–≥–æ–≤–æ—Ä –≤ –≥–æ—Ä–æ–¥–µ –∂–∏–≤–æ—Ç–Ω—ã—Ö.', poster: 'https://image.tmdb.org/t/p/w500/hlK0e0wAQ3VLuJcsfIYPvb4JVud.jpg', rating: '8.0', year: '2016', director: '–ë–∞–π—Ä–æ–Ω –•–æ–≤–∞—Ä–¥', movieGenres: ['–ö–æ–º–µ–¥–∏—è', '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 129, title: '–£–Ω–µ—Å—ë–Ω–Ω—ã–µ –ø—Ä–∏–∑—Ä–∞–∫–∞–º–∏', overview: '–î–µ–≤–æ—á–∫–∞ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ –º–∏—Ä –¥—É—Ö–æ–≤ –∏ –¥–æ–ª–∂–Ω–∞ —Å–ø–∞—Å—Ç–∏ —Ä–æ–¥–∏—Ç–µ–ª–µ–π.', poster: 'https://image.tmdb.org/t/p/w500/39wmItIWsg5sZMyRUHLkWBcuVCM.jpg', rating: '8.6', year: '2001', director: '–•–∞—è–æ –ú–∏—è–¥–∑–∞–∫–∏', movieGenres: ['–ú—É–ª—å—Ç—Ñ–∏–ª—å–º', '–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 324857, title: '–ß–µ–ª–æ–≤–µ–∫-–ø–∞—É–∫: –ß–µ—Ä–µ–∑ –≤—Å–µ–ª–µ–Ω–Ω—ã–µ', overview: '–ú–∞–π–ª–∑ –ú–æ—Ä–∞–ª–µ—Å –≤—Å—Ç—Ä–µ—á–∞–µ—Ç –õ—é–¥–µ–π-–ø–∞—É–∫–æ–≤ –∏–∑ –¥—Ä—É–≥–∏—Ö –∏–∑–º–µ—Ä–µ–Ω–∏–π.', poster: 'https://image.tmdb.org/t/p/w500/iiZZdoQBEYBv6id8su7ImL0oCbD.jpg', rating: '8.4', year: '2018', director: '–ë–æ–± –ü–µ—Ä—Å–∏—á–µ—Ç—Ç–∏', movieGenres: ['–ú—É–ª—å—Ç—Ñ–∏–ª—å–º', '–ë–æ–µ–≤–∏–∫'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 1022789, title: '–ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞ 2', overview: '–†–∞–π–ª–∏ –ø–µ—Ä–µ–∂–∏–≤–∞–µ—Ç –ø–æ–¥—Ä–æ—Å—Ç–∫–æ–≤—ã–π –≤–æ–∑—Ä–∞—Å—Ç —Å –Ω–æ–≤—ã–º–∏ —ç–º–æ—Ü–∏—è–º–∏.', poster: 'https://image.tmdb.org/t/p/w500/oxxqiyWrnM0XPnBtVe9TgYWnPxT.jpg', rating: '7.7', year: '2024', director: '–ö–µ–ª—Å–∏ –ú–∞–Ω–Ω', movieGenres: ['–ö–æ–º–µ–¥–∏—è', '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º'], languages: ['rus', 'eng'], type: 'movie' },

            // –£–∂–∞—Å—ã / –¢—Ä–∏–ª–ª–µ—Ä
            { id: 346, title: '–°–µ–º—å', overview: '–î–≤–∞ –¥–µ—Ç–µ–∫—Ç–∏–≤–∞ –æ—Ö–æ—Ç—è—Ç—Å—è –Ω–∞ —É–±–∏–π—Ü—É, –∏—Å–ø–æ–ª—å–∑—É—é—â–µ–≥–æ —Å–µ–º—å —Å–º–µ—Ä—Ç–Ω—ã—Ö –≥—Ä–µ—Ö–æ–≤.', poster: 'https://image.tmdb.org/t/p/w500/6yoghtyTpznpBik8EngEmJskVUO.jpg', rating: '8.6', year: '1995', director: '–î—ç–≤–∏–¥ –§–∏–Ω—á–µ—Ä', movieGenres: ['–£–∂–∞—Å—ã', '–¢—Ä–∏–ª–ª–µ—Ä'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 694, title: '–°–∏—è–Ω–∏–µ', overview: '–°–µ–º—å—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–º–æ—Ç—Ä–∏—Ç–µ–ª—è–º–∏ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –æ—Ç–µ–ª—è –∑–∏–º–æ–π.', poster: 'https://image.tmdb.org/t/p/w500/nRj5511mZdTl4saWEPoj9QroTIu.jpg', rating: '8.4', year: '1980', director: '–°—Ç—ç–Ω–ª–∏ –ö—É–±—Ä–∏–∫', movieGenres: ['–£–∂–∞—Å—ã', '–¢—Ä–∏–ª–ª–µ—Ä'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 348, title: '–ß—É–∂–æ–π', overview: '–≠–∫–∏–ø–∞–∂ –∫–æ—Å–º–∏—á–µ—Å–∫–æ–≥–æ –∫–æ—Ä–∞–±–ª—è —Å—Ç–∞–ª–∫–∏–≤–∞–µ—Ç—Å—è —Å —Å–º–µ—Ä—Ç–æ–Ω–æ—Å–Ω—ã–º —Å—É—â–µ—Å—Ç–≤–æ–º.', poster: 'https://image.tmdb.org/t/p/w500/vfrQk5IPloGg1v9Rzbh2Eg3VGyM.jpg', rating: '8.5', year: '1979', director: '–†–∏–¥–ª–∏ –°–∫–æ—Ç—Ç', movieGenres: ['–£–∂–∞—Å—ã', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 745, title: '–®–µ—Å—Ç–æ–µ —á—É–≤—Å—Ç–≤–æ', overview: '–ú–∞–ª—å—á–∏–∫ –≤–∏–¥–∏—Ç –ø—Ä–∏–∑—Ä–∞–∫–æ–≤ –∏ –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –∫ –ø—Å–∏—Ö–æ–ª–æ–≥—É.', poster: 'https://image.tmdb.org/t/p/w500/fIssD3w3SvIhPPmVo4WMgZDVLID.jpg', rating: '8.1', year: '1999', director: '–ú. –ù–∞–π—Ç –®—å—è–º–∞–ª–∞–Ω', movieGenres: ['–£–∂–∞—Å—ã', '–¢—Ä–∏–ª–ª–µ—Ä'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 447332, title: '–¢–∏—Ö–æ–µ –º–µ—Å—Ç–æ', overview: '–°–µ–º—å—è –≤—ã–∂–∏–≤–∞–µ—Ç –≤ –º–∏—Ä–µ, –≥–¥–µ —à—É–º –ø—Ä–∏–≤–ª–µ–∫–∞–µ—Ç –º–æ–Ω—Å—Ç—Ä–æ–≤.', poster: 'https://image.tmdb.org/t/p/w500/nAU74GmpUk7t5iklEp3bufwDq4n.jpg', rating: '7.5', year: '2018', director: '–î–∂–æ–Ω –ö—Ä–∞—Å–∏–Ω—Å–∫–∏', movieGenres: ['–£–∂–∞—Å—ã', '–¢—Ä–∏–ª–ª–µ—Ä'], languages: ['rus', 'eng'], type: 'movie' },

            // –ú–µ–ª–æ–¥—Ä–∞–º–∞
            { id: 597, title: '–¢–∏—Ç–∞–Ω–∏–∫', overview: '–ê—Ä–∏—Å—Ç–æ–∫—Ä–∞—Ç–∫–∞ –≤–ª—é–±–ª—è–µ—Ç—Å—è –≤ –±–µ–¥–Ω–æ–≥–æ —Ö—É–¥–æ–∂–Ω–∏–∫–∞ –Ω–∞ –æ–±—Ä–µ—á—ë–Ω–Ω–æ–º –∫–æ—Ä–∞–±–ª–µ.', poster: 'https://image.tmdb.org/t/p/w500/9xjZS2rlVxm8SFx8kPC3aIGCOYQ.jpg', rating: '7.9', year: '1997', director: '–î–∂–µ–π–º—Å –ö—ç–º–µ—Ä–æ–Ω', movieGenres: ['–ú–µ–ª–æ–¥—Ä–∞–º–∞', '–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'movie' },
            { id: 313369, title: '–õ–∞-–õ–∞ –õ–µ–Ω–¥', overview: '–ü–∏–∞–Ω–∏—Å—Ç –∏ –∞–∫—Ç—Ä–∏—Å–∞ –≤–ª—é–±–ª—è—é—Ç—Å—è, —Å—Ç—Ä–µ–º—è—Å—å –∫ –º–µ—á—Ç–∞–º –≤ –õ–æ—Å-–ê–Ω–¥–∂–µ–ª–µ—Å–µ.', poster: 'https://image.tmdb.org/t/p/w500/uDO8zWDhfWwoFdKS4fzkUJt0Rf0.jpg', rating: '8.0', year: '2016', director: '–î—ç–º—å–µ–Ω –®–∞–∑–µ–ª–ª', movieGenres: ['–ú–µ–ª–æ–¥—Ä–∞–º–∞', '–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'movie' },

            // === –°–ï–†–ò–ê–õ–´ (TV SERIES) ===
            { id: 1399, title: '–ò–≥—Ä–∞ –ø—Ä–µ—Å—Ç–æ–ª–æ–≤', overview: '–ë–ª–∞–≥–æ—Ä–æ–¥–Ω—ã–µ —Å–µ–º—å–∏ –±–æ—Ä—é—Ç—Å—è –∑–∞ –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –ñ–µ–ª–µ–∑–Ω—ã–º —Ç—Ä–æ–Ω–æ–º.', poster: 'https://image.tmdb.org/t/p/w500/1XS1oqL89opfnbLl8WnZY1O1uJx.jpg', rating: '8.4', year: '2011', director: '–î—ç–≤–∏–¥ –ë–µ–Ω–∏–æ—Ñ—Ñ', movieGenres: ['–î—Ä–∞–º–∞', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'series' },
            { id: 1396, title: '–í–æ –≤—Å–µ —Ç—è–∂–∫–∏–µ', overview: '–£—á–∏—Ç–µ–ª—å —Ö–∏–º–∏–∏ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –Ω–∞—Ä–∫–æ–±–∞—Ä–æ–Ω–æ–º –ø–æ—Å–ª–µ –¥–∏–∞–≥–Ω–æ–∑–∞ —Ä–∞–∫–∞.', poster: 'https://image.tmdb.org/t/p/w500/3xnWaLQjelJDDF7LT1WBo6f4BRe.jpg', rating: '9.5', year: '2008', director: '–í–∏–Ω—Å –ì–∏–ª–ª–∏–≥–∞–Ω', movieGenres: ['–î—Ä–∞–º–∞', '–¢—Ä–∏–ª–ª–µ—Ä'], languages: ['rus', 'eng'], type: 'series' },
            { id: 66732, title: '–û—á–µ–Ω—å —Å—Ç—Ä–∞–Ω–Ω—ã–µ –¥–µ–ª–∞', overview: '–î–µ—Ç–∏ —Å—Ç–∞–ª–∫–∏–≤–∞—é—Ç—Å—è —Å–æ —Å–≤–µ—Ä—Ö—ä–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ —Å–∏–ª–∞–º–∏ –≤ –º–∞–ª–µ–Ω—å–∫–æ–º –≥–æ—Ä–æ–¥–∫–µ.', poster: 'https://image.tmdb.org/t/p/w500/49WJfeN0moxb9IPfGn8AIqMGskD.jpg', rating: '8.6', year: '2016', director: '–ë—Ä–∞—Ç—å—è –î–∞—Ñ—Ñ–µ—Ä', movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–£–∂–∞—Å—ã'], languages: ['rus', 'eng'], type: 'series' },
            { id: 71912, title: '–í–µ–¥—å–º–∞–∫', overview: '–û—Ö–æ—Ç–Ω–∏–∫ –Ω–∞ –º–æ–Ω—Å—Ç—Ä–æ–≤ –∏—â–µ—Ç —Å–≤–æ—ë –º–µ—Å—Ç–æ –≤ –º–∏—Ä–µ, –≥–¥–µ –ª—é–¥–∏ –æ–ø–∞—Å–Ω–µ–µ –∑–≤–µ—Ä–µ–π.', poster: 'https://image.tmdb.org/t/p/w500/7vjaCdMw15FEbXyLQTVa04URsPm.jpg', rating: '8.0', year: '2019', director: '–õ–æ—Ä–µ–Ω –®–º–∏–¥—Ç', movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–ë–æ–µ–≤–∏–∫'], languages: ['rus', 'eng'], type: 'series' },
            { id: 94997, title: '–î–æ–º –î—Ä–∞–∫–æ–Ω–∞', overview: '–ü—Ä–∏–∫–≤–µ–ª ¬´–ò–≥—Ä—ã –ø—Ä–µ—Å—Ç–æ–ª–æ–≤¬ª –æ –≥—Ä–∞–∂–¥–∞–Ω—Å–∫–æ–π –≤–æ–π–Ω–µ –¢–∞—Ä–≥–∞—Ä–∏–µ–Ω–æ–≤.', poster: 'https://image.tmdb.org/t/p/w500/z2yahl2uefxDCl0nogcRBstwruJ.jpg', rating: '8.4', year: '2022', director: '–ú–∏–≥–µ–ª—å –°–∞–ø–æ—á–Ω–∏–∫', movieGenres: ['–î—Ä–∞–º–∞', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'series' },
            { id: 60625, title: '–†–∏–∫ –∏ –ú–æ—Ä—Ç–∏', overview: '–ì–µ–Ω–∏–∞–ª—å–Ω—ã–π —É—á—ë–Ω—ã–π –∏ –µ–≥–æ –≤–Ω—É–∫ –ø—É—Ç–µ—à–µ—Å—Ç–≤—É—é—Ç –ø–æ –º—É–ª—å—Ç–∏–≤—Å–µ–ª–µ–Ω–Ω—ã–º.', poster: 'https://image.tmdb.org/t/p/w500/cvhNj9eoRBe5SxjCbQTkh05UP5K.jpg', rating: '8.7', year: '2013', director: '–î—ç–Ω –•–∞—Ä–º–æ–Ω', movieGenres: ['–ö–æ–º–µ–¥–∏—è', '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞'], languages: ['rus', 'eng'], type: 'series' },
            { id: 100088, title: '–ü–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑ –Ω–∞—Å', overview: '–ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–∏—Å—Ç —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ—Ç –¥–µ–≤–æ—á–∫—É —á–µ—Ä–µ–∑ –ø–æ—Å—Ç–∞–ø–æ–∫–∞–ª–∏–ø—Ç–∏—á–µ—Å–∫—É—é –ê–º–µ—Ä–∏–∫—É.', poster: 'https://image.tmdb.org/t/p/w500/uKvVjHNqB5VmOrdxqAt2F7J78ED.jpg', rating: '8.8', year: '2023', director: '–ö—Ä—ç–π–≥ –ú–µ–π–∑–∏–Ω', movieGenres: ['–î—Ä–∞–º–∞', '–ë–æ–µ–≤–∏–∫'], languages: ['rus', 'eng'], type: 'series' },
            { id: 456, title: '–°–∏–º–ø—Å–æ–Ω—ã', overview: '–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è –∂—ë–ª—Ç–æ–π —Å–µ–º–µ–π–∫–∏ –∏–∑ –°–ø—Ä–∏–Ω–≥—Ñ–∏–ª–¥–∞.', poster: 'https://image.tmdb.org/t/p/w500/tubgEpjTUA7t0kejVMBsNBZDarZ.jpg', rating: '8.0', year: '1989', director: '–ú—ç—Ç—Ç –ì—Ä–µ–π–Ω–∏–Ω–≥', movieGenres: ['–ö–æ–º–µ–¥–∏—è', '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º'], languages: ['rus', 'eng'], type: 'series' },
            { id: 1418, title: '–¢–µ–æ—Ä–∏—è –±–æ–ª—å—à–æ–≥–æ –≤–∑—Ä—ã–≤–∞', overview: '–ì–µ–Ω–∏–∞–ª—å–Ω—ã–µ —Ñ–∏–∑–∏–∫–∏ –∏ –∏—Ö –¥—Ä—É–∑—å—è —Å–ø—Ä–∞–≤–ª—è—é—Ç—Å—è —Å –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω–æ–π –∂–∏–∑–Ω—å—é.', poster: 'https://image.tmdb.org/t/p/w500/ooBGRQBdbGzBxAVfExiO8r7kloA.jpg', rating: '7.8', year: '2007', director: '–ß–∞–∫ –õ–æ—Ä—Ä–∏', movieGenres: ['–ö–æ–º–µ–¥–∏—è'], languages: ['rus', 'eng'], type: 'series' },
            { id: 82856, title: '–ú–∞–Ω–¥–∞–ª–æ—Ä–µ—Ü', overview: '–û–¥–∏–Ω–æ–∫–∏–π –æ—Ö–æ—Ç–Ω–∏–∫ –∑–∞ –≥–æ–ª–æ–≤–∞–º–∏ –ø—É—Ç–µ—à–µ—Å—Ç–≤—É–µ—Ç –ø–æ –¥–∞–ª—ë–∫–∏–º —É–≥–æ–ª–∫–∞–º –≥–∞–ª–∞–∫—Ç–∏–∫–∏.', poster: 'https://image.tmdb.org/t/p/w500/sWgBv7LV2PRoQgkxwlibdGXKz1S.jpg', rating: '8.5', year: '2019', director: '–î–∂–æ–Ω –§–∞–≤—Ä–æ', movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–ë–æ–µ–≤–∏–∫'], languages: ['rus', 'eng'], type: 'series' },
            { id: 93405, title: '–ò–≥—Ä–∞ –≤ –∫–∞–ª—å–º–∞—Ä–∞', overview: '–°–æ—Ç–Ω–∏ –∏–≥—Ä–æ–∫–æ–≤ —Å–æ—Ä–µ–≤–Ω—É—é—Ç—Å—è –≤ –¥–µ—Ç—Å–∫–∏—Ö –∏–≥—Ä–∞—Ö –∑–∞ –æ–≥—Ä–æ–º–Ω—ã–π –ø—Ä–∏–∑.', poster: 'https://image.tmdb.org/t/p/w500/dDlEmu3EZ0Pgg93K2SVNLCjCSvE.jpg', rating: '7.8', year: '2021', director: '–•–≤–∞–Ω –î–æ–Ω-—Ö—ë–∫', movieGenres: ['–î—Ä–∞–º–∞', '–¢—Ä–∏–ª–ª–µ—Ä'], languages: ['rus', 'eng'], type: 'series' },
            { id: 1402, title: '–•–æ–¥—è—á–∏–µ –º–µ—Ä—Ç–≤–µ—Ü—ã', overview: '–í—ã–∂–∏–≤—à–∏–µ –±–æ—Ä—é—Ç—Å—è –∑–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –≤ –º–∏—Ä–µ, –∑–∞—Ö–≤–∞—á–µ–Ω–Ω–æ–º –∑–æ–º–±–∏.', poster: 'https://image.tmdb.org/t/p/w500/xf9wuDcqlUPWABZNeDKPbZUjWx0.jpg', rating: '8.1', year: '2010', director: '–§—Ä—ç–Ω–∫ –î–∞—Ä–∞–±–æ–Ω—Ç', movieGenres: ['–£–∂–∞—Å—ã', '–î—Ä–∞–º–∞'], languages: ['rus', 'eng'], type: 'series' },
            { id: 84958, title: '–õ–æ–∫–∏', overview: '–ë–æ–≥ –æ–±–º–∞–Ω–∞ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ TVA –∏ –ø—É—Ç–µ—à–µ—Å—Ç–≤—É–µ—Ç –ø–æ –≤—Ä–µ–º–µ–Ω–∏.', poster: 'https://image.tmdb.org/t/p/w500/voHUmluYmKyleFkTu3lOXQG702u.jpg', rating: '8.2', year: '2021', director: '–ú–∞–π–∫–ª –£–æ–ª–¥—Ä–æ–Ω', movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–ë–æ–µ–≤–∏–∫'], languages: ['rus', 'eng'], type: 'series' }
        ];
        // ============================================
        // ARCHITECTURE: Centralized State Management
        // ============================================

        // Session State Machine
        const SessionState = {
            SETUP: 'setup',
            SWIPING: 'swiping',
            WAITING_FOR_MATCHES: 'waiting_for_matches',
            SELECTING: 'selecting',
            WAITING_FOR_SELECTION: 'waiting_for_selection',
            FINAL: 'final'
        };

        // Valid state transitions for safety
        const VALID_TRANSITIONS = {
            [SessionState.SETUP]: [SessionState.SWIPING],
            [SessionState.SWIPING]: [SessionState.WAITING_FOR_MATCHES],
            [SessionState.WAITING_FOR_MATCHES]: [SessionState.SELECTING, SessionState.FINAL],
            [SessionState.SELECTING]: [SessionState.WAITING_FOR_SELECTION],
            [SessionState.WAITING_FOR_SELECTION]: [SessionState.FINAL],
            [SessionState.FINAL]: []
        };

        // ============================================
        // Firebase Manager - Centralized Firebase Operations
        // ============================================
        class FirebaseManager {
            constructor() {
                this.listeners = new Map(); // listener_id -> {ref, eventType, callback}
                this.listenerCounter = 0;
            }

            addListener(ref, eventType, callback) {
                if (!database) return null;

                const listenerId = `listener_${this.listenerCounter++}`;
                ref.on(eventType, callback);
                this.listeners.set(listenerId, { ref, eventType, callback });
                console.log(`[Firebase] Listener added: ${listenerId} (total: ${this.listeners.size})`);
                return listenerId;
            }

            removeListener(listenerId) {
                if (!this.listeners.has(listenerId)) return false;

                const { ref, eventType, callback } = this.listeners.get(listenerId);
                ref.off(eventType, callback);
                this.listeners.delete(listenerId);
                console.log(`[Firebase] Listener removed: ${listenerId} (remaining: ${this.listeners.size})`);
                return true;
            }

            removeAllListeners() {
                console.log(`[Firebase] Removing all listeners (${this.listeners.size})`);
                this.listeners.forEach(({ ref, eventType, callback }) => {
                    ref.off(eventType, callback);
                });
                this.listeners.clear();
            }

            async write(path, data) {
                if (!database) return false;
                try {
                    await database.ref(path).set(data);
                    console.log(`[Firebase] Write success: ${path}`, data);
                    return true;
                } catch (error) {
                    console.error(`[Firebase] Write error: ${path}`, error);
                    return false;
                }
            }

            async update(path, data) {
                if (!database) return false;
                try {
                    await database.ref(path).update(data);
                    console.log(`[Firebase] Update success: ${path}`, data);
                    return true;
                } catch (error) {
                    console.error(`[Firebase] Update error: ${path}`, error);
                    return false;
                }
            }

            async read(path) {
                if (!database) return null;
                try {
                    const snapshot = await database.ref(path).once('value');
                    let data = snapshot.val();

                    // Firebase can convert arrays to objects - normalize them back
                    if (data && typeof data === 'object') {
                        data = this._normalizeFirebaseData(data);
                    }

                    console.log(`[Firebase] Read success: ${path}`, data);
                    return data;
                } catch (error) {
                    console.error(`[Firebase] Read error: ${path}`, error);
                    return null;
                }
            }

            _normalizeFirebaseData(data) {
                // Recursively convert Firebase objects that look like arrays back to arrays
                if (Array.isArray(data)) {
                    return data.map(item => this._normalizeFirebaseData(item));
                }

                if (data && typeof data === 'object') {
                    // Check if object has only numeric keys starting from 0 (Firebase array pattern)
                    const keys = Object.keys(data);
                    const isArrayLike = keys.length > 0 &&
                                       keys.every(key => /^\d+$/.test(key)) &&
                                       keys.map(k => parseInt(k)).sort((a, b) => a - b)
                                           .every((val, idx) => val === idx);

                    if (isArrayLike) {
                        // Convert to array
                        const arr = [];
                        keys.forEach(key => {
                            arr[parseInt(key)] = this._normalizeFirebaseData(data[key]);
                        });
                        return arr;
                    }

                    // Regular object - recurse into properties
                    const normalized = {};
                    Object.keys(data).forEach(key => {
                        normalized[key] = this._normalizeFirebaseData(data[key]);
                    });
                    return normalized;
                }

                return data;
            }

            getHealthStatus() {
                return {
                    connected: !!database,
                    activeListeners: this.listeners.size,
                    listenerIds: Array.from(this.listeners.keys())
                };
            }
        }

        // ============================================
        // Session Manager - Centralized State Management
        // ============================================
        class SessionManager {
            constructor() {
                this.state = SessionState.SETUP;
                this.data = {
                    sessionId: null,
                    isHost: false,
                    selectedGenres: [],
                    selectedCountries: [],
                    selectedLanguages: ['rus', 'eng'], // Default both languages selected
                    minRating: 7.0, // Default minimum rating
                    includeMovies: true, // Include movies in search
                    includeSeries: false, // Include TV series in search
                    movieCount: 20,
                    minYear: 2000,
                    movies: [],
                    currentMovieIndex: 0,
                    userChoices: {},
                    partnerChoices: {},
                    matchedMovies: [],
                    selectedMovieId: null,
                    partnerSelectedMovieId: null,
                    isConfirmed: false
                };
                this.eventHandlers = new Map(); // event -> [callbacks]
                this.stateHistory = []; // For debugging
            }

            // State management with validation
            transitionTo(newState) {
                const currentState = this.state;

                if (!VALID_TRANSITIONS[currentState] || !VALID_TRANSITIONS[currentState].includes(newState)) {
                    console.error(`[SessionManager] Invalid transition: ${currentState} -> ${newState}`);
                    this.logHealthCheck();
                    return false;
                }

                console.log(`[SessionManager] State transition: ${currentState} -> ${newState}`);
                this.stateHistory.push({ from: currentState, to: newState, timestamp: Date.now() });
                this.state = newState;
                this.emit('stateChange', { from: currentState, to: newState });
                return true;
            }

            // Event system for coordination
            on(eventName, callback) {
                if (!this.eventHandlers.has(eventName)) {
                    this.eventHandlers.set(eventName, []);
                }
                this.eventHandlers.get(eventName).push(callback);
            }

            emit(eventName, data) {
                const handlers = this.eventHandlers.get(eventName) || [];
                handlers.forEach(callback => {
                    try {
                        callback(data);
                    } catch (error) {
                        console.error(`[SessionManager] Event handler error (${eventName}):`, error);
                    }
                });
            }

            // Data access
            get(key) {
                return this.data[key];
            }

            set(key, value) {
                const oldValue = this.data[key];
                this.data[key] = value;
                console.log(`[SessionManager] Data updated: ${key}`, { old: oldValue, new: value });
                this.emit('dataChange', { key, oldValue, newValue: value });
            }

            // Batch update for related data
            update(updates) {
                Object.entries(updates).forEach(([key, value]) => {
                    this.set(key, value);
                });
            }

            // Health check for debugging
            logHealthCheck() {
                console.log('[SessionManager] Health Check:', {
                    state: this.state,
                    sessionId: this.data.sessionId,
                    isHost: this.data.isHost,
                    movieCount: this.data.movies.length,
                    currentIndex: this.data.currentMovieIndex,
                    choicesCount: Object.keys(this.data.userChoices).length,
                    partnerChoicesCount: Object.keys(this.data.partnerChoices).length,
                    stateHistory: this.stateHistory.slice(-5)
                });
            }

            // Reset session
            reset() {
                console.log('[SessionManager] Resetting session');
                this.state = SessionState.SETUP;
                this.data = {
                    sessionId: null,
                    isHost: false,
                    selectedGenres: [],
                    selectedCountries: [],
                    selectedLanguages: ['rus', 'eng'], // Default both languages selected
                    minRating: 7.0, // Default minimum rating
                    includeMovies: true, // Include movies in search
                    includeSeries: false, // Include TV series in search
                    movieCount: 20,
                    minYear: 2000,
                    movies: [],
                    currentMovieIndex: 0,
                    userChoices: {},
                    partnerChoices: {},
                    matchedMovies: [],
                    selectedMovieId: null,
                    partnerSelectedMovieId: null,
                    isConfirmed: false
                };
                this.stateHistory = [];
                this.emit('reset');
            }
        }

        // ============================================
        // Initialize Managers
        // ============================================
        const firebaseManager = new FirebaseManager();
        const sessionManager = new SessionManager();

        // Legacy compatibility - proxy to SessionManager
        let currentCardCleanup = null;

        // Proxy getters/setters for backward compatibility
        Object.defineProperty(window, 'sessionId', {
            get: () => sessionManager.get('sessionId'),
            set: (value) => sessionManager.set('sessionId', value)
        });
        Object.defineProperty(window, 'isHost', {
            get: () => sessionManager.get('isHost'),
            set: (value) => sessionManager.set('isHost', value)
        });
        Object.defineProperty(window, 'selectedGenres', {
            get: () => sessionManager.get('selectedGenres'),
            set: (value) => sessionManager.set('selectedGenres', value)
        });
        Object.defineProperty(window, 'selectedCountries', {
            get: () => sessionManager.get('selectedCountries'),
            set: (value) => sessionManager.set('selectedCountries', value)
        });
        Object.defineProperty(window, 'movieCount', {
            get: () => sessionManager.get('movieCount'),
            set: (value) => sessionManager.set('movieCount', value)
        });
        Object.defineProperty(window, 'minYear', {
            get: () => sessionManager.get('minYear'),
            set: (value) => sessionManager.set('minYear', value)
        });
        Object.defineProperty(window, 'selectedLanguages', {
            get: () => sessionManager.get('selectedLanguages'),
            set: (value) => sessionManager.set('selectedLanguages', value)
        });
        Object.defineProperty(window, 'minRating', {
            get: () => sessionManager.get('minRating'),
            set: (value) => sessionManager.set('minRating', value)
        });
        Object.defineProperty(window, 'includeMovies', {
            get: () => sessionManager.get('includeMovies'),
            set: (value) => sessionManager.set('includeMovies', value)
        });
        Object.defineProperty(window, 'includeSeries', {
            get: () => sessionManager.get('includeSeries'),
            set: (value) => sessionManager.set('includeSeries', value)
        });
        Object.defineProperty(window, 'movies', {
            get: () => sessionManager.get('movies'),
            set: (value) => sessionManager.set('movies', value)
        });
        Object.defineProperty(window, 'currentMovieIndex', {
            get: () => sessionManager.get('currentMovieIndex'),
            set: (value) => sessionManager.set('currentMovieIndex', value)
        });
        Object.defineProperty(window, 'userChoices', {
            get: () => sessionManager.get('userChoices'),
            set: (value) => sessionManager.set('userChoices', value)
        });
        Object.defineProperty(window, 'partnerChoices', {
            get: () => sessionManager.get('partnerChoices'),
            set: (value) => sessionManager.set('partnerChoices', value)
        });
        Object.defineProperty(window, 'matchedMovies', {
            get: () => sessionManager.get('matchedMovies'),
            set: (value) => sessionManager.set('matchedMovies', value)
        });
        Object.defineProperty(window, 'selectedMovieId', {
            get: () => sessionManager.get('selectedMovieId'),
            set: (value) => sessionManager.set('selectedMovieId', value)
        });
        Object.defineProperty(window, 'partnerSelectedMovieId', {
            get: () => sessionManager.get('partnerSelectedMovieId'),
            set: (value) => sessionManager.set('partnerSelectedMovieId', value)
        });
        Object.defineProperty(window, 'isConfirmed', {
            get: () => sessionManager.get('isConfirmed'),
            set: (value) => sessionManager.set('isConfirmed', value)
        });
        Object.defineProperty(window, 'currentSessionState', {
            get: () => sessionManager.state,
            set: (value) => {
                console.warn('[DEPRECATED] Direct state assignment. Use sessionManager.transitionTo()');
                sessionManager.state = value;
            }
        });

        function addFirebaseListener(ref, eventType, callback) {
            return firebaseManager.addListener(ref, eventType, callback);
        }

        function cleanupFirebaseListeners() {
            firebaseManager.removeAllListeners();
        }

        function cleanupAllListeners() {
            if (currentCardCleanup) {
                currentCardCleanup();
                currentCardCleanup = null;
            }
            firebaseManager.removeAllListeners();
        }

        // Health monitoring - called periodically
        setInterval(() => {
            const fbHealth = firebaseManager.getHealthStatus();
            if (fbHealth.activeListeners > 10) {
                console.warn('[Health Check] Too many Firebase listeners:', fbHealth);
                sessionManager.logHealthCheck();
            }
        }, 30000); // Check every 30 seconds

        // Helper function for fetch with retry and error handling
        async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);

                    if (!response.ok) {
                        if (response.status === 429) {
                            // Rate limiting - wait longer
                            console.warn(`Rate limited (429). Retry ${i + 1}/${retries}`);
                            await new Promise(resolve => setTimeout(resolve, delay * (i + 2)));
                            continue;
                        } else if (response.status >= 500) {
                            // Server error - retry
                            console.warn(`Server error (${response.status}). Retry ${i + 1}/${retries}`);
                            await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
                            continue;
                        } else if (response.status === 401) {
                            // Unauthorized - API key issue
                            throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á TMDB');
                        } else {
                            // Other HTTP error
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    }

                    return response;
                } catch (error) {
                    if (i === retries - 1) {
                        // Last attempt failed
                        throw error;
                    }
                    console.warn(`Fetch error: ${error.message}. Retry ${i + 1}/${retries}`);
                    await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
                }
            }
        }

        // Initialize UI
        function initializeUI() {
            // Setup genres
            const genreGrid = document.getElementById('genreGrid');
            genres.forEach(genre => {
                const btn = document.createElement('button');
                btn.className = 'genre-btn';
                btn.textContent = genre.name;
                btn.onclick = () => toggleGenre(genre.id, btn);
                genreGrid.appendChild(btn);
            });

            // Setup countries
            const countryGrid = document.getElementById('countryGrid');
            countries.forEach(country => {
                const btn = document.createElement('button');
                btn.className = 'genre-btn';
                btn.textContent = country.name;
                btn.onclick = () => toggleCountry(country.code, btn);
                countryGrid.appendChild(btn);
            });

            // Setup movie count slider
            const slider = document.getElementById('movieCountSlider');
            const valueDisplay = document.getElementById('movieCountValue');
            slider.oninput = () => {
                movieCount = parseInt(slider.value);
                valueDisplay.textContent = movieCount;
            };

            // Setup year slider
            const yearSlider = document.getElementById('yearSlider');
            const yearValue = document.getElementById('yearValue');
            yearSlider.oninput = () => {
                minYear = parseInt(yearSlider.value);
                yearValue.textContent = minYear;
            };

            // Setup language checkboxes
            const langRussian = document.getElementById('langRussian');
            const langEnglish = document.getElementById('langEnglish');

            function updateSelectedLanguages() {
                const langs = [];
                if (langRussian.checked) langs.push('rus');
                if (langEnglish.checked) langs.push('eng');
                selectedLanguages = langs;
            }

            langRussian.onchange = updateSelectedLanguages;
            langEnglish.onchange = updateSelectedLanguages;

            // Setup rating slider
            const ratingSlider = document.getElementById('ratingSlider');
            const ratingValue = document.getElementById('ratingValue');
            ratingSlider.oninput = () => {
                minRating = parseFloat(ratingSlider.value);
                ratingValue.textContent = `‚≠ê ${minRating.toFixed(1)}+`;
            };

            // Setup content type checkboxes
            const includeMoviesCheckbox = document.getElementById('includeMovies');
            const includeSeriesCheckbox = document.getElementById('includeSeries');

            includeMoviesCheckbox.onchange = () => {
                // Ensure at least one is selected
                if (!includeMoviesCheckbox.checked && !includeSeriesCheckbox.checked) {
                    includeMoviesCheckbox.checked = true;
                    showToast('–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–±—Ä–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞', 'warning', 2000);
                    return;
                }
                includeMovies = includeMoviesCheckbox.checked;
            };
            includeSeriesCheckbox.onchange = () => {
                // Ensure at least one is selected
                if (!includeSeriesCheckbox.checked && !includeMoviesCheckbox.checked) {
                    includeSeriesCheckbox.checked = true;
                    showToast('–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–±—Ä–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞', 'warning', 2000);
                    return;
                }
                includeSeries = includeSeriesCheckbox.checked;
            };
        }

        function toggleGenre(genreId, btn) {
            const index = selectedGenres.indexOf(genreId);
            if (index > -1) {
                selectedGenres.splice(index, 1);
                btn.classList.remove('selected');
            } else {
                selectedGenres.push(genreId);
                btn.classList.add('selected');
            }
        }

        function toggleCountry(countryCode, btn) {
            const index = selectedCountries.indexOf(countryCode);
            if (index > -1) {
                selectedCountries.splice(index, 1);
                btn.classList.remove('selected');
            } else {
                selectedCountries.push(countryCode);
                btn.classList.add('selected');
            }
        }

        async function createSession() {
            if (selectedGenres.length === 0) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∂–∞–Ω—Ä!');
                return;
            }

            if (selectedLanguages.length === 0) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —è–∑—ã–∫!');
                return;
            }

            if (!includeMovies && !includeSeries) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞ (—Ñ–∏–ª—å–º—ã –∏–ª–∏ —Å–µ—Ä–∏–∞–ª—ã)!');
                return;
            }

            // IMPORTANT: Save user selections BEFORE reset
            const userSelections = {
                genres: [...selectedGenres],
                countries: [...selectedCountries],
                languages: [...selectedLanguages],
                minRating: minRating,
                includeMovies: includeMovies,
                includeSeries: includeSeries,
                movieCount: movieCount,
                minYear: minYear
            };
            console.log('[createSession] Saved user selections before reset:', userSelections);

            // Clean up any previous session data
            console.log('[createSession] Cleaning up old data...');
            firebaseManager.removeAllListeners();
            sessionManager.reset();

            // Restore user selections after reset
            selectedGenres = userSelections.genres;
            selectedCountries = userSelections.countries;
            selectedLanguages = userSelections.languages;
            minRating = userSelections.minRating;
            includeMovies = userSelections.includeMovies;
            includeSeries = userSelections.includeSeries;
            movieCount = userSelections.movieCount;
            minYear = userSelections.minYear;
            console.log('[createSession] Restored user selections after reset:', {
                selectedGenres,
                selectedCountries,
                selectedLanguages,
                minRating,
                includeMovies,
                includeSeries,
                movieCount,
                minYear
            });

            sessionId = generateSessionId();
            isHost = true;

            // Update URL with session parameter so host can refresh page
            const newUrl = `${window.location.pathname}?session=${sessionId}`;
            window.history.replaceState({ sessionId: sessionId }, '', newUrl);
            console.log('Updated host URL with session:', newUrl);

            // Create session in Firebase first
            if (database) {
                // Show link screen immediately
                showScreen('linkScreen');
                document.querySelector('.session-info h2').textContent = '–°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏...';
                const link = `${window.location.origin}${window.location.pathname}?session=${sessionId}`;
                document.getElementById('sessionLink').textContent = link;
                document.querySelector('.session-link').style.display = 'block';
                document.querySelector('.waiting-message p').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–ª—å–º–æ–≤...';

                // Update session code display
                updateSessionCodeDisplay();

                try {
                    const sessionDataToSave = {
                        genres: selectedGenres,
                        countries: selectedCountries,
                        languages: selectedLanguages,
                        minRating: minRating,
                        includeMovies: includeMovies,
                        includeSeries: includeSeries,
                        movieCount: movieCount,
                        minYear: minYear,
                        host: true,
                        partner: false,
                        hostChoices: {},
                        partnerChoices: {},
                        created: Date.now()
                    };
                    console.log('[createSession] Saving session data:', JSON.stringify(sessionDataToSave, null, 2));

                    const success = await firebaseManager.write(`sessions/${sessionId}`, sessionDataToSave);

                    if (!success) {
                        throw new Error('Failed to write session to Firebase');
                    }
                    console.log('[createSession] Session created in Firebase:', sessionId);
                } catch (error) {
                    console.error('Error creating session in Firebase:', error);
                    alert('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Å—Å–∏–∏: ' + error.message);
                    showScreen('setupScreen');
                    return;
                }

                // Check if partner already joined (in case they joined while we were creating session)
                const checkPartner = async () => {
                    try {
                        const partnerJoined = await firebaseManager.read(`sessions/${sessionId}/partner`);
                        console.log('Initial partner check:', partnerJoined);

                        if (partnerJoined === true) {
                            console.log('Partner already joined, starting swipe phase immediately');
                            startSwipePhase();
                            return true;
                        }
                        return false;
                    } catch (error) {
                        console.error('Error checking partner status:', error);
                        return false;
                    }
                };

                // Check first, then set up listener if needed
                const alreadyJoined = await checkPartner();
                if (!alreadyJoined) {
                    console.log('Partner not joined yet, setting up listener...');
                    // Listen for partner joining
                    let partnerJoinedFlag = false;
                    const partnerRef = database.ref(`sessions/${sessionId}/partner`);
                    const partnerJoinCallback = (snapshot) => {
                        const value = snapshot.val();
                        console.log('Partner listener triggered, value:', value);
                        if (value === true && !partnerJoinedFlag) {
                            partnerJoinedFlag = true;
                            console.log('Partner joined, starting swipe phase');
                            // Cleanup this specific listener since partner joined
                            const listenerId = sessionManager.get('partnerJoinListenerId');
                            if (listenerId) {
                                firebaseManager.removeListener(listenerId);
                                sessionManager.set('partnerJoinListenerId', null);
                            }
                            startSwipePhase();
                        }
                    };
                    const listenerId = firebaseManager.addListener(partnerRef, 'value', partnerJoinCallback);
                    sessionManager.set('partnerJoinListenerId', listenerId);
                }
            } else {
                // Demo mode - show loading
                showScreen('linkScreen');
                document.querySelector('.session-info h2').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–ª—å–º–æ–≤...';
                document.querySelector('.session-link').style.display = 'none';
                document.querySelector('.waiting-message p').textContent = '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...';
            }

            // Fetch movies in background
            try {
                console.log('Host: Starting to fetch movies...');
                await fetchMovies();
                console.log('Host: Movies fetched successfully, count:', movies.length);

                if (movies.length === 0) {
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∏–ª—å–º—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–∏–µ –∂–∞–Ω—Ä—ã –∏–ª–∏ —Å—Ç—Ä–∞–Ω—ã.');
                    showScreen('setupScreen');
                    return;
                }

                // Save movies to Firebase so partner can read them
                if (database) {
                    console.log('Host: Saving movies to Firebase...');
                    console.log('Host: Movies to save:', movies.length, 'movies');
                    console.log('Host: First 3 movie IDs:', movies.slice(0, 3).map(m => m.id));
                    console.log('Host: First movie title:', movies[0] ? movies[0].title : 'N/A');
                    try {
                        await firebaseManager.update(`sessions/${sessionId}`, {
                            movies: movies,
                            moviesReady: true
                        });
                        console.log('Host: Movies saved to Firebase successfully');
                    } catch (error) {
                        console.error('Host: Error saving movies to Firebase:', error);
                    }
                }

                // Save session to localStorage after movies are loaded
                saveSessionToStorage();

                // Update status after movies loaded
                if (database) {
                    document.querySelector('.session-info h2').textContent = '–°–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞!';
                    document.querySelector('.waiting-message p').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤—Ç–æ—Ä–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞...';

                    // Check again if partner joined while we were fetching movies
                    console.log('Host: Checking if partner joined while fetching movies...');
                    try {
                        const partnerJoined = await firebaseManager.read(`sessions/${sessionId}/partner`);
                        if (partnerJoined === true) {
                            console.log('Host: Partner already joined! Starting swipe phase now.');
                            startSwipePhase();
                        } else {
                            console.log('Host: Partner not joined yet, waiting...');
                        }
                    } catch (error) {
                        console.error('Host: Error checking partner status after fetch:', error);
                    }
                } else {
                    // Demo mode - start immediately
                    startSwipePhase();
                }
            } catch (error) {
                console.error('Error in createSession:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∏–ª—å–º–æ–≤: ' + error.message);
                showScreen('setupScreen');
                return;
            }
        }

        async function joinSession(sessionId) {
            // Clean up any previous session data
            console.log('Joining session - cleaning up old data...');
            firebaseManager.removeAllListeners();
            sessionManager.reset();

            // Show loading
            showScreen('linkScreen');
            document.querySelector('.session-info h2').textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Å—Å–∏–∏...';
            document.querySelector('.session-link').style.display = 'none';

            if (database) {
                try {
                    console.log('Attempting to join session:', sessionId);
                    const sessionData = await firebaseManager.read(`sessions/${sessionId}`);

                    console.log('Session data exists:', sessionData !== null);

                    if (!sessionData) {
                        console.error('Session not found:', sessionId);
                        alert('–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞! –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω–∞ –µ—â—ë –Ω–µ —Å–æ–∑–¥–∞–Ω–∞ –∏–ª–∏ –∏—Å—Ç–µ–∫–ª–∞.');
                        window.location.href = window.location.pathname; // Redirect to home
                        return;
                    }

                    console.log('[joinSession] Session data received:', JSON.stringify(sessionData, null, 2));
                    console.log('[joinSession] Session data keys:', Object.keys(sessionData));
                    console.log('[joinSession] genres value:', sessionData.genres, 'type:', typeof sessionData.genres, 'isArray:', Array.isArray(sessionData.genres));

                    // Validate session data
                    try {
                        validateSessionData(sessionData);
                    } catch (validationError) {
                        console.error('[joinSession] Session validation failed:', validationError);
                        console.error('[joinSession] Session data that failed:', JSON.stringify(sessionData, null, 2));
                        alert('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏: ' + validationError.message);
                        window.location.href = window.location.pathname;
                        return;
                    }

                    selectedGenres = sessionData.genres;
                    selectedCountries = sessionData.countries || [];
                    selectedLanguages = sessionData.languages || ['rus', 'eng'];
                    minRating = sessionData.minRating || 7.0;
                    includeMovies = sessionData.includeMovies !== false; // Default true
                    includeSeries = sessionData.includeSeries || false;
                    movieCount = sessionData.movieCount;
                    minYear = sessionData.minYear || 2000;
                    isHost = false;

                    // IMPORTANT: Set the global sessionId for use in startSwipePhase and checkMatches
                    // The function parameter shadows the global, so we need to explicitly set it
                    sessionManager.set('sessionId', sessionId);
                    console.log('[joinSession] Set global sessionId:', sessionId);

                    // Mark partner as joined (use update to avoid overwriting host data)
                    console.log('Setting partner: true in Firebase...');
                    const success = await firebaseManager.update(`sessions/${sessionId}`, { partner: true });
                    if (!success) {
                        throw new Error('Failed to mark partner as joined');
                    }
                    console.log('Successfully set partner: true');

                    // Verify the update
                    const verifyData = await firebaseManager.read(`sessions/${sessionId}`);
                    console.log('Verified session data after update:', verifyData);

                    // Listen for host choices
                    const hostChoicesRef = database.ref(`sessions/${sessionId}/hostChoices`);
                    const hostChoicesListenerId = firebaseManager.addListener(
                        hostChoicesRef,
                        'value',
                        (snapshot) => {
                            partnerChoices = snapshot.val() || {};
                        }
                    );
                    sessionManager.set('hostChoicesListenerId', hostChoicesListenerId);

                    // Wait for host to load movies and read from Firebase
                    console.log('Partner: Waiting for host to load movies...');
                    document.querySelector('.session-info h2').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∏–ª—å–º–æ–≤...';
                    document.querySelector('.waiting-message p').textContent = '–•–æ—Å—Ç –∑–∞–≥—Ä—É–∂–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ñ–∏–ª—å–º–æ–≤...';

                    // Check if movies already loaded
                    if (sessionData.moviesReady && sessionData.movies) {
                        console.log('Partner: Movies already loaded by host, using them');
                        console.log('Partner: sessionData.movies length:', sessionData.movies.length);
                        console.log('Partner: sessionData.movies type:', typeof sessionData.movies, Array.isArray(sessionData.movies));
                        movies = sessionData.movies;
                        console.log('Partner: Loaded', movies.length, 'movies from Firebase');
                        console.log('Partner: First 3 movie IDs:', movies.slice(0, 3).map(m => m.id));
                        console.log('Partner: First movie title:', movies[0] ? movies[0].title : 'N/A');

                        // Save session to localStorage after joining
                        saveSessionToStorage();

                        startSwipePhase();
                    } else {
                        // Movies not ready yet, wait for them
                        console.log('Partner: Movies not ready, setting up listener...');
                        const moviesRef = database.ref(`sessions/${sessionId}/moviesReady`);
                        let moviesLoaded = false;

                        const moviesReadyCallback = async (snapshot) => {
                            const ready = snapshot.val();
                            if (ready === true && !moviesLoaded) {
                                moviesLoaded = true;
                                console.log('Partner: Movies ready, loading...');

                                // Remove listener
                                const listenerId = sessionManager.get('moviesReadyListenerId');
                                if (listenerId) {
                                    firebaseManager.removeListener(listenerId);
                                    sessionManager.set('moviesReadyListenerId', null);
                                }

                                // Read movies from Firebase
                                const moviesData = await firebaseManager.read(`sessions/${sessionId}/movies`);
                                if (moviesData) {
                                    console.log('Partner: moviesData length:', moviesData.length);
                                    console.log('Partner: moviesData type:', typeof moviesData, Array.isArray(moviesData));
                                    movies = moviesData;
                                    console.log('Partner: Loaded', movies.length, 'movies from Firebase (listener)');
                                    console.log('Partner: First 3 movie IDs:', movies.slice(0, 3).map(m => m.id));
                                    console.log('Partner: First movie title:', movies[0] ? movies[0].title : 'N/A');

                                    // Save session to localStorage after joining
                                    saveSessionToStorage();

                                    startSwipePhase();
                                } else {
                                    console.error('Partner: Failed to load movies from Firebase');
                                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ñ–∏–ª—å–º–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ.');
                                    window.location.href = window.location.pathname;
                                }
                            }
                        };

                        const listenerId = firebaseManager.addListener(moviesRef, 'value', moviesReadyCallback);
                        sessionManager.set('moviesReadyListenerId', listenerId);

                        // Timeout after 30 seconds
                        setTimeout(() => {
                            if (!moviesLoaded) {
                                const listenerId = sessionManager.get('moviesReadyListenerId');
                                if (listenerId) {
                                    firebaseManager.removeListener(listenerId);
                                    sessionManager.set('moviesReadyListenerId', null);
                                }
                                alert('–í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∏–ª—å–º–æ–≤ –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ.');
                                window.location.href = window.location.pathname;
                            }
                        }, 30000);
                    }
                } catch (error) {
                    console.error('Error joining session:', error);
                    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ —Å–µ—Å—Å–∏–∏: ' + error.message);
                    window.location.href = window.location.pathname;
                }
            } else {
                alert('Firebase –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ —Å–µ—Å—Å–∏–∏.');
                window.location.href = window.location.pathname;
            }
        }

        // Helper function to filter embedded movies based on user preferences
        function getFilteredEmbeddedMovies() {
            console.log('Filtering embedded movies with user preferences...');
            console.log('Selected genres:', selectedGenres);
            console.log('Selected countries:', selectedCountries);
            console.log('Selected languages:', selectedLanguages);
            console.log('Min rating:', minRating);
            console.log('Min year:', minYear);
            console.log('Movie count:', movieCount);

            // Get genre names from selected genre IDs
            const selectedGenreNames = selectedGenres.map(genreId => {
                const genre = genres.find(g => g.id === genreId);
                return genre ? genre.name : null;
            }).filter(name => name !== null);
            console.log('Selected genre names:', selectedGenreNames);

            // Filter movies that match user criteria
            const filtered = embeddedMovies.filter(movie => {
                // Check year filter
                const movieYear = parseInt(movie.year);
                if (movieYear < minYear) return false;

                // Check rating filter
                const movieRating = parseFloat(movie.rating);
                if (movieRating < minRating) return false;

                // Check language filter - movie must have at least one selected language
                const hasMatchingLanguage = movie.languages.some(lang => selectedLanguages.includes(lang));
                if (!hasMatchingLanguage) return false;

                // Check if movie has at least one selected genre
                const hasMatchingGenre = selectedGenreNames.some(genreName =>
                    movie.movieGenres.includes(genreName)
                );
                if (!hasMatchingGenre) return false;

                return true;
            });

            console.log(`Filtered ${filtered.length} embedded movies matching criteria`);

            // Shuffle and return requested amount
            const shuffled = filtered.sort(() => Math.random() - 0.5);
            const result = shuffled.slice(0, movieCount);

            // If not enough movies after filtering, add random movies to reach movieCount
            const MIN_EMBEDDED = 5;
            const targetCount = Math.max(movieCount, MIN_EMBEDDED);

            if (result.length < targetCount) {
                console.log(`Not enough filtered movies (${result.length}), adding random movies to reach ${targetCount}`);
                const existingIds = new Set(result.map(m => m.id));
                const remainingCount = targetCount - result.length;
                const shuffledAll = embeddedMovies
                    .filter(m => !existingIds.has(m.id)) // Avoid duplicates
                    .sort(() => Math.random() - 0.5);
                const additional = shuffledAll.slice(0, remainingCount);
                result.push(...additional);
            }

            console.log(`Returning ${result.length} embedded movies`);
            // Add type field to all embedded movies (they are all movies, not series)
            return result.map(movie => ({ ...movie, type: 'movie' }));
        }

        async function fetchMovies(retryCount = 0, maxRetries = 3) {
            const shouldFetchMovies = sessionManager.get('includeMovies');
            const shouldFetchSeries = sessionManager.get('includeSeries');

            console.log(`fetchMovies() attempt ${retryCount + 1}/${maxRetries + 1} with ${movieCount} items requested`);
            console.log(`[fetchMovies] Fetching: movies=${shouldFetchMovies}, series=${shouldFetchSeries}`);

            // Update loading message with retry info
            if (document.querySelector('.waiting-message p')) {
                const contentType = shouldFetchMovies && shouldFetchSeries ? '–∫–æ–Ω—Ç–µ–Ω—Ç–∞' :
                                    shouldFetchSeries ? '—Å–µ—Ä–∏–∞–ª–æ–≤' : '—Ñ–∏–ª—å–º–æ–≤';
                if (retryCount > 0) {
                    document.querySelector('.waiting-message p').textContent = `–ó–∞–≥—Ä—É–∑–∫–∞ ${contentType}... (–ø–æ–ø—ã—Ç–∫–∞ ${retryCount + 1}/${maxRetries + 1})`;
                } else {
                    document.querySelector('.waiting-message p').textContent = `–ó–∞–≥—Ä—É–∑–∫–∞ ${contentType}...`;
                }
            }

            // If TMDB API key not configured, use embedded movies
            if (TMDB_API_KEY === 'YOUR_TMDB_API_KEY') {
                console.log('TMDB API key not configured, using embedded movies');
                movies = getFilteredEmbeddedMovies();
                console.log('Embedded movies loaded:', movies.length);
                return;
            }

            // Try to fetch real content from TMDB
            console.log('TMDB API key found, fetching content...');
            try {
                const countryParam = selectedCountries.length > 0 ? selectedCountries.join('|') : '';
                const pagesNeeded = Math.ceil(movieCount / 20);
                const allContent = [];

                // Randomize sorting method for variety
                const sortOptions = [
                    'popularity.desc',
                    'vote_average.desc',
                    'vote_count.desc'
                ];
                const randomSort = sortOptions[Math.floor(Math.random() * sortOptions.length)];
                console.log('Using random sort:', randomSort);

                // Start from a random page (1-10) for more variety
                const startPage = Math.floor(Math.random() * 10) + 1;
                console.log('Starting from random page:', startPage);

                // Fetch movies if enabled
                if (shouldFetchMovies) {
                    const movieGenreParam = selectedGenres.join(',');
                    console.log('[fetchMovies] Fetching movies with genres:', movieGenreParam);

                    for (let i = 0; i < Math.min(pagesNeeded, 5); i++) {
                        const page = startPage + i;
                        let url = `${TMDB_BASE_URL}/discover/movie?api_key=${TMDB_API_KEY}&with_genres=${movieGenreParam}&language=ru-RU&sort_by=${randomSort}&page=${page}&include_adult=false&vote_average.gte=${minRating}&primary_release_date.gte=${minYear}-01-01`;

                        if (countryParam) {
                            url += `&with_origin_country=${countryParam}`;
                        }

                        console.log(`Fetching movies page ${page}...`);
                        const response = await fetchWithRetry(url);
                        const data = await response.json();
                        console.log(`Movies page ${page} returned ${data.results?.length || 0} items`);

                        const filteredResults = (data.results || []).filter(movie => {
                            const year = movie.release_date ? parseInt(movie.release_date.split('-')[0]) : 0;
                            return movie.vote_average >= minRating && year >= minYear;
                        }).map(movie => ({ ...movie, _type: 'movie' })); // Add type marker

                        allContent.push(...filteredResults);
                        if (allContent.length >= movieCount * 1.5) break;
                    }
                }

                // Fetch TV series if enabled
                if (shouldFetchSeries) {
                    // Map movie genre IDs to TV genre IDs
                    const tvGenreIds = selectedGenres.map(id => tvGenreMapping[id] || id);
                    const tvGenreParam = [...new Set(tvGenreIds)].join(','); // Remove duplicates
                    console.log('[fetchMovies] Fetching TV series with genres:', tvGenreParam);

                    for (let i = 0; i < Math.min(pagesNeeded, 5); i++) {
                        const page = startPage + i;
                        let url = `${TMDB_BASE_URL}/discover/tv?api_key=${TMDB_API_KEY}&with_genres=${tvGenreParam}&language=ru-RU&sort_by=${randomSort}&page=${page}&include_adult=false&vote_average.gte=${minRating}&first_air_date.gte=${minYear}-01-01`;

                        if (countryParam) {
                            url += `&with_origin_country=${countryParam}`;
                        }

                        console.log(`Fetching TV page ${page}...`);
                        const response = await fetchWithRetry(url);
                        const data = await response.json();
                        console.log(`TV page ${page} returned ${data.results?.length || 0} items`);

                        const filteredResults = (data.results || []).filter(show => {
                            const year = show.first_air_date ? parseInt(show.first_air_date.split('-')[0]) : 0;
                            return show.vote_average >= minRating && year >= minYear;
                        }).map(show => ({ ...show, _type: 'series' })); // Add type marker

                        allContent.push(...filteredResults);
                        if (allContent.length >= movieCount * 1.5) break;
                    }
                }

                console.log(`Total content fetched: ${allContent.length}`);

                // Process all content (movies and series)
                console.log(`Processing content data...`);

                const processedContent = allContent.slice(0, movieCount * 1.5).map(item => {
                    try {
                        const isMovie = item._type === 'movie';
                        const title = isMovie ? item.title : item.name;
                        const releaseDate = isMovie ? item.release_date : item.first_air_date;

                        // Convert genre_ids to genre names
                        const genreList = isMovie ? genres : tvGenres;
                        const itemGenres = (item.genre_ids || [])
                            .map(id => {
                                const genre = genreList.find(g => g.id === id);
                                // Fallback to movie genres for common IDs
                                if (!genre) {
                                    const movieGenre = genres.find(g => g.id === id);
                                    return movieGenre ? movieGenre.name : null;
                                }
                                return genre.name;
                            })
                            .filter(name => name !== null);

                        // Determine languages
                        const availableLanguages = ['rus']; // All content has Russian localization
                        if (item.original_language === 'en' || item.vote_count > 50) {
                            availableLanguages.push('eng');
                        }

                        return {
                            id: item.id,
                            title: title,
                            overview: item.overview || '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç',
                            poster: item.poster_path ? `${TMDB_IMAGE_BASE}${item.poster_path}` : 'üé¨',
                            rating: item.vote_average ? item.vote_average.toFixed(1) : 'N/A',
                            year: releaseDate ? releaseDate.split('-')[0] : 'N/A',
                            director: 'TMDB',
                            movieGenres: itemGenres,
                            languages: availableLanguages,
                            type: item._type, // 'movie' or 'series'
                            // Additional fields for series (will be populated later if needed)
                            episodeCount: null,
                            seasonCount: null,
                            runtime: null
                        };
                    } catch (err) {
                        console.warn('Error processing item:', item.title || item.name, err);
                        return null;
                    }
                }).filter(item => item !== null);

                // Filter by selected languages
                const languageFilteredContent = processedContent.filter(item => {
                    return item.languages.some(lang => selectedLanguages.includes(lang));
                });

                console.log(`Loaded ${languageFilteredContent.length} items after language filtering (from ${processedContent.length})`);

                if (languageFilteredContent.length === 0) {
                    if (retryCount < maxRetries) {
                        console.warn(`No content found. Retrying... (${retryCount + 1}/${maxRetries})`);
                        console.log(`[fetchMovies] Retrying... (${retryCount + 1}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await fetchMovies(retryCount + 1, maxRetries);
                    } else {
                        console.error('Max retries exceeded. Using embedded movies database as fallback.');
                        showToast('‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é –±–∞–∑—É —Ñ–∏–ª—å–º–æ–≤ (TMDB –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)', 'warning', 5000);
                        movies = getFilteredEmbeddedMovies();
                        console.log(`Loaded ${movies.length} embedded movies as fallback`);
                    }
                } else {
                    // Shuffle the array for randomness
                    const shuffled = languageFilteredContent.sort(() => Math.random() - 0.5);
                    movies = shuffled.slice(0, movieCount);

                    const movieCount_ = movies.filter(m => m.type === 'movie').length;
                    const seriesCount = movies.filter(m => m.type === 'series').length;
                    console.log(`Successfully loaded ${movies.length} items from TMDB (${movieCount_} movies, ${seriesCount} series)`);

                    // If we got less than requested, supplement with embedded movies
                    const MIN_MOVIES = 5;
                    if (movies.length < movieCount || movies.length < MIN_MOVIES) {
                        const needed = Math.max(movieCount - movies.length, MIN_MOVIES - movies.length);
                        if (needed > 0) {
                            console.log(`[fetchMovies] Got only ${movies.length}/${movieCount} items from TMDB (min: ${MIN_MOVIES}), supplementing with embedded movies`);
                            const embeddedMovies = getFilteredEmbeddedMovies();
                            const existingIds = new Set(movies.map(m => m.id));
                            const additionalMovies = embeddedMovies.filter(m => !existingIds.has(m.id));
                            movies = [...movies, ...additionalMovies.slice(0, needed)];
                            console.log(`[fetchMovies] Supplemented with ${Math.min(needed, additionalMovies.length)} embedded movies, total: ${movies.length}`);

                            if (movies.length < MIN_MOVIES) {
                                console.warn(`[fetchMovies] Still only ${movies.length} items, adding more from full embedded database`);
                                const allEmbedded = embeddedMovies.sort(() => Math.random() - 0.5);
                                const moreNeeded = MIN_MOVIES - movies.length;
                                const moreMovies = allEmbedded.filter(m => !existingIds.has(m.id)).slice(0, moreNeeded);
                                movies = [...movies, ...moreMovies];
                                console.log(`[fetchMovies] Final content count: ${movies.length}`);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error fetching content:', error);

                if (retryCount < maxRetries) {
                    console.log(`Retrying after error... (${retryCount + 1}/${maxRetries})`);
                    console.log(`[fetchMovies] Error: ${error.message}. Retrying... (${retryCount + 1}/${maxRetries})`);
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    return await fetchMovies(retryCount + 1, maxRetries);
                } else {
                    console.error('Max retries exceeded after errors. Using embedded movies database as fallback.');
                    showToast('‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é –±–∞–∑—É —Ñ–∏–ª—å–º–æ–≤ (TMDB –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)', 'warning', 5000);
                    movies = getFilteredEmbeddedMovies();
                    console.log(`Loaded ${movies.length} embedded movies as fallback after errors`);
                }
            }

            console.log('fetchMovies() completed. Total items:', movies.length);
        }

        function startSwipePhase() {
            console.log('Starting swipe phase, state:', SessionState.SWIPING);
            console.log('startSwipePhase: movies count:', movies.length);
            console.log('startSwipePhase: First 3 movie IDs:', movies.slice(0, 3).map(m => m.id));
            console.log('startSwipePhase: isHost:', isHost);

            const transitioned = sessionManager.transitionTo(SessionState.SWIPING);
            if (!transitioned) {
                console.error('Failed to transition to SWIPING');
                return;
            }
            showScreen('swipeScreen');

            // Display session code if available
            if (sessionId) {
                document.getElementById('sessionCodeDisplay').style.display = 'block';
                document.getElementById('sessionCodeText').textContent = sessionId;
            }

            // Display selected genres
            const genreTags = document.getElementById('genreTags');
            genreTags.innerHTML = selectedGenres.map(genreId => {
                const genre = genres.find(g => g.id === genreId);
                return `<span class="genre-tag">${genre ? genre.name : ''}</span>`;
            }).join('');

            // Listen for partner completion if in Firebase mode
            // This listener will be cleaned up when we enter WAITING_FOR_MATCHES state
            if (database && sessionId) {
                const partnerChoicesKey = isHost ? 'partnerChoices' : 'hostChoices';
                const partnerChoicesRef = database.ref(`sessions/${sessionId}/${partnerChoicesKey}`);
                const listenerId = firebaseManager.addListener(
                    partnerChoicesRef,
                    'value',
                    (snapshot) => {
                        const choices = snapshot.val() || {};
                        // Only show partner status if we're still in SWIPING state
                        if (currentSessionState === SessionState.SWIPING &&
                            Object.keys(choices).length >= movies.length &&
                            currentMovieIndex < movies.length) {
                            document.getElementById('partnerStatus').classList.add('show');
                        }
                    }
                );
                sessionManager.set('partnerChoicesSwipeListenerId', listenerId);
            }

            renderCurrentCard();
        }

        function renderCurrentCard() {
            const cardStack = document.getElementById('cardStack');
            cardStack.innerHTML = '<div class="swipe-indicator left" id="dislikeIndicator">‚úó</div><div class="swipe-indicator right" id="likeIndicator">‚ô•</div>';

            if (currentMovieIndex >= movies.length) {
                checkMatches();
                return;
            }

            const movie = movies[currentMovieIndex];
            const card = document.createElement('div');
            card.className = 'movie-card';
            card.id = 'currentCard';

            // Language badges
            const languageBadges = movie.languages && movie.languages.length > 0
                ? `<div class="language-badges">
                    ${movie.languages.map(lang => `<span class="language-badge ${lang}">${lang}</span>`).join('')}
                   </div>`
                : '';

            // Content type badge (movie or series)
            const contentType = movie.type || 'movie';
            const typeBadge = contentType === 'series'
                ? `<div class="content-type-badge series">üì∫ –°–µ—Ä–∏–∞–ª</div>`
                : `<div class="content-type-badge movie">üé¨ –§–∏–ª—å–º</div>`;

            const posterContent = movie.poster && movie.poster.startsWith('http')
                ? `<div class="movie-poster">
                    <img src="${escapeHtml(movie.poster)}" alt="${escapeHtml(movie.title)}" onerror="this.parentElement.innerHTML='<div class=\\'poster-placeholder\\'><span class=\\'poster-emoji\\'>${movie.poster || 'üé¨'}</span><span class=\\'poster-title\\'>${escapeHtml(movie.title)}</span></div>'">
                    ${typeBadge}
                    ${languageBadges}
                    ${movie.rating !== 'N/A' ? `<div class="movie-rating">‚≠ê ${escapeHtml(movie.rating)}</div>` : ''}
                   </div>`
                : `<div class="movie-poster">
                    <div class="poster-placeholder">
                        <span class="poster-emoji">${movie.poster || 'üé¨'}</span>
                        <span class="poster-title">${escapeHtml(movie.title)}</span>
                    </div>
                    ${typeBadge}
                    ${languageBadges}
                    ${movie.rating !== 'N/A' ? `<div class="movie-rating">‚≠ê ${escapeHtml(movie.rating)}</div>` : ''}
                   </div>`;

            const genresHtml = movie.movieGenres && movie.movieGenres.length > 0
                ? `<div class="movie-genres">${movie.movieGenres.slice(0, 3).map(g => `<span class="movie-genre">${escapeHtml(g)}</span>`).join('')}</div>`
                : '';

            const metaHtml = `
                <div class="movie-meta">
                    ${movie.year !== 'N/A' ? `<span>üìÖ ${escapeHtml(movie.year)}</span>` : ''}
                    ${movie.director !== '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω' ? `<span>üé¨ ${escapeHtml(movie.director)}</span>` : ''}
                </div>
            `;

            card.innerHTML = `
                ${posterContent}
                <div class="movie-info">
                    <div class="movie-title">${escapeHtml(movie.title)}</div>
                    ${metaHtml}
                    ${genresHtml}
                    <div class="movie-description">${escapeHtml(movie.overview)}</div>
                </div>
            `;

            cardStack.appendChild(card);
            setupSwipeHandlers(card);
            updateProgress();
            updateCounter();
        }

        function setupSwipeHandlers(card) {
            // Cleanup previous card's listeners
            if (currentCardCleanup) {
                currentCardCleanup();
            }

            let startX = 0;
            let currentX = 0;
            let isDragging = false;

            const dislikeIndicator = document.getElementById('dislikeIndicator');
            const likeIndicator = document.getElementById('likeIndicator');

            function startDrag(e) {
                isDragging = true;
                startX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
                card.classList.add('swiping');
            }

            function drag(e) {
                if (!isDragging) return;
                currentX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                const diff = currentX - startX;
                card.style.transform = `translateX(${diff}px) rotate(${diff * 0.1}deg)`;

                if (diff < -50) {
                    dislikeIndicator.classList.add('visible');
                    likeIndicator.classList.remove('visible');
                } else if (diff > 50) {
                    likeIndicator.classList.add('visible');
                    dislikeIndicator.classList.remove('visible');
                } else {
                    dislikeIndicator.classList.remove('visible');
                    likeIndicator.classList.remove('visible');
                }
            }

            function endDrag() {
                if (!isDragging) return;
                isDragging = false;
                card.classList.remove('swiping');

                const diff = currentX - startX;
                if (Math.abs(diff) > 100) {
                    swipe(diff > 0 ? 'like' : 'dislike');
                } else {
                    card.style.transform = '';
                    dislikeIndicator.classList.remove('visible');
                    likeIndicator.classList.remove('visible');
                }
            }

            // Attach listeners to card
            card.addEventListener('mousedown', startDrag);
            card.addEventListener('touchstart', startDrag);

            // Attach listeners to document
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);

            // Store cleanup function
            currentCardCleanup = function() {
                card.removeEventListener('mousedown', startDrag);
                card.removeEventListener('touchstart', startDrag);
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchend', endDrag);
            };
        }

        async function swipe(choice) {
            const movie = movies[currentMovieIndex];
            userChoices[movie.id] = choice === 'like';

            // Save to Firebase and wait for completion
            const savePromise = (database && sessionId)
                ? (async () => {
                    const choicesKey = isHost ? 'hostChoices' : 'partnerChoices';
                    await firebaseManager.write(`sessions/${sessionId}/${choicesKey}/${movie.id}`, choice === 'like');
                  })()
                : Promise.resolve();

            const card = document.getElementById('currentCard');
            if (card) {
                const direction = choice === 'like' ? 1 : -1;
                card.style.transform = `translateX(${direction * 1000}px) rotate(${direction * 50}deg)`;
                setTimeout(() => {
                    // Wait for Firebase write to complete before proceeding
                    savePromise.then(() => {
                        currentMovieIndex++;
                        // Save session after each swipe
                        saveSessionToStorage();
                        renderCurrentCard();
                    });
                }, 300);
            } else {
                // Wait for Firebase write to complete before proceeding
                savePromise.then(() => {
                    currentMovieIndex++;
                    // Save session after each swipe
                    saveSessionToStorage();
                    renderCurrentCard();
                });
            }
        }

        function updateProgress() {
            const progress = (currentMovieIndex / movies.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        function updateCounter() {
            const remaining = movies.length - currentMovieIndex;
            document.getElementById('moviesRemaining').textContent = remaining;
        }

        async function checkMatches() {
            // Guard: prevent re-entry if we already moved past SWIPING
            if (currentSessionState !== SessionState.SWIPING) {
                console.log('checkMatches() called but already in state:', currentSessionState, '- ignoring');
                return;
            }

            console.log('[checkMatches] Starting - transitioning to WAITING_FOR_MATCHES');
            const transitioned = sessionManager.transitionTo(SessionState.WAITING_FOR_MATCHES);
            if (!transitioned) {
                console.error('[checkMatches] Failed to transition to WAITING_FOR_MATCHES');
                return;
            }

            // Clean up swipe phase listeners (but not all - we'll add new ones)
            if (currentCardCleanup) {
                currentCardCleanup();
                currentCardCleanup = null;
            }
            // Remove only the swipe phase listener
            const swipeListenerId = sessionManager.get('partnerChoicesSwipeListenerId');
            if (swipeListenerId) {
                firebaseManager.removeListener(swipeListenerId);
                sessionManager.set('partnerChoicesSwipeListenerId', null);
            }

            if (!database || !sessionId) {
                // Demo mode - simulate partner choices
                movies.forEach(movie => {
                    partnerChoices[movie.id] = Math.random() > 0.5;
                });
                setTimeout(() => showMatches(), 500);
                return;
            }

            const finishedKey = isHost ? 'hostFinished' : 'partnerFinished';
            const partnerChoicesKey = isHost ? 'partnerChoices' : 'hostChoices';
            const partnerFinishedKey = isHost ? 'partnerFinished' : 'hostFinished';

            showScreen('linkScreen');
            document.querySelector('.session-info h2').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –ø–∞—Ä—Ç–Ω–µ—Ä–∞...';
            document.querySelector('.waiting-message p').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—ã–±–æ—Ä–∞...';

            let matchesShown = false;

            const showMatchesOnce = async () => {
                if (matchesShown) return;
                matchesShown = true;
                console.log('[checkMatches] showMatchesOnce triggered');

                // Clean up listeners
                const finishedListenerId = sessionManager.get('partnerFinishedListenerId');
                if (finishedListenerId) {
                    firebaseManager.removeListener(finishedListenerId);
                    sessionManager.set('partnerFinishedListenerId', null);
                }
                const choicesListenerId = sessionManager.get('partnerChoicesWaitListenerId');
                if (choicesListenerId) {
                    firebaseManager.removeListener(choicesListenerId);
                    sessionManager.set('partnerChoicesWaitListenerId', null);
                }

                // Load partner choices
                const choices = await firebaseManager.read(`sessions/${sessionId}/${partnerChoicesKey}`);
                partnerChoices = choices || {};
                console.log('[checkMatches] Partner choices loaded:', Object.keys(partnerChoices).length);

                showMatches();
            };

            // IMPORTANT: Set up listener BEFORE writing our finished flag
            // This prevents race condition where partner finishes between our write and listener setup
            const partnerFinishedRef = database.ref(`sessions/${sessionId}/${partnerFinishedKey}`);
            const checkPartnerFinishedCallback = (snapshot) => {
                const partnerFinished = snapshot.val();
                console.log('[checkMatches] Partner finished status:', partnerFinished);
                if (partnerFinished === true) {
                    showMatchesOnce();
                }
            };

            const listenerId = firebaseManager.addListener(partnerFinishedRef, 'value', checkPartnerFinishedCallback);
            sessionManager.set('partnerFinishedListenerId', listenerId);
            console.log('[checkMatches] Listener set up for partnerFinished');

            // NOW mark ourselves as finished
            await firebaseManager.write(`sessions/${sessionId}/${finishedKey}`, true);
            console.log('[checkMatches] Marked as finished in Firebase');

            // Also check partner choices count as backup
            const partnerChoicesRef = database.ref(`sessions/${sessionId}/${partnerChoicesKey}`);
            const partnerChoicesListenerId = firebaseManager.addListener(partnerChoicesRef, 'value', (snapshot) => {
                const choices = snapshot.val() || {};
                const choicesCount = Object.keys(choices).length;
                console.log('[checkMatches] Partner choices count:', choicesCount, '/', movies.length);
                if (choicesCount >= movies.length) {
                    showMatchesOnce();
                }
            });
            sessionManager.set('partnerChoicesWaitListenerId', partnerChoicesListenerId);

            // Add timeout after 5 minutes
            setTimeout(() => {
                if (!matchesShown) {
                    matchesShown = true;
                    // Clean up listeners
                    const finishedListenerId = sessionManager.get('partnerFinishedListenerId');
                    if (finishedListenerId) {
                        firebaseManager.removeListener(finishedListenerId);
                        sessionManager.set('partnerFinishedListenerId', null);
                    }
                    const choicesListenerId = sessionManager.get('partnerChoicesWaitListenerId');
                    if (choicesListenerId) {
                        firebaseManager.removeListener(choicesListenerId);
                        sessionManager.set('partnerChoicesWaitListenerId', null);
                    }
                    alert('–í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –ø–∞—Ä—Ç–Ω–µ—Ä–∞ –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é.');
                    startOver();
                }
            }, 5 * 60 * 1000); // 5 minutes
        }

        function showMatches() {
            console.log('showMatches() - transitioning to SELECTING');

            // Guard: ensure movies are loaded
            if (!movies || movies.length === 0) {
                console.error('showMatches() called but movies not loaded yet!');
                console.error('Current state:', {
                    movies: movies,
                    moviesLength: movies ? movies.length : 0,
                    userChoices: Object.keys(userChoices).length,
                    partnerChoices: Object.keys(partnerChoices).length
                });
                return; // Don't show error, just return - movies might still be loading
            }

            const transitioned = sessionManager.transitionTo(SessionState.SELECTING);
            if (!transitioned) {
                console.error('Failed to transition to SELECTING');
                return;
            }

            const matches = movies.filter(movie =>
                userChoices[movie.id] === true && partnerChoices[movie.id] === true
            );

            if (matches.length === 0) {
                alert('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑!');
                startOver();
                return;
            }

            if (matches.length === 1) {
                showFinalChoice(matches[0]);
                return;
            }

            // Save matched movies for later reference
            matchedMovies = matches;

            // Set up real-time listener for partner's selection
            if (database && sessionId) {
                const partnerSelectionKey = isHost ? 'partnerCurrentSelection' : 'hostCurrentSelection';
                const partnerSelectionRef = database.ref(`sessions/${sessionId}/${partnerSelectionKey}`);

                const listenerId = firebaseManager.addListener(partnerSelectionRef, 'value', (snapshot) => {
                    const newPartnerSelection = snapshot.val();
                    console.log('Partner selection changed:', newPartnerSelection);
                    partnerSelectedMovieId = newPartnerSelection;
                    renderMatchesGrid(); // Re-render to show partner's choice
                });
                sessionManager.set('partnerSelectionListenerId', listenerId);
            }

            showScreen('resultsScreen');
            renderMatchesGrid();
        }

        function renderMatchesGrid() {
            const matchesGrid = document.getElementById('matchesGrid');
            const bothSelectedSame = selectedMovieId && selectedMovieId === partnerSelectedMovieId;

            matchesGrid.innerHTML = matchedMovies.map(movie => {
                // Content type badge for results
                const contentType = movie.type || 'movie';
                const typeBadgeSmall = contentType === 'series'
                    ? `<span class="type-badge-small series">üì∫</span>`
                    : `<span class="type-badge-small movie">üé¨</span>`;

                const posterContent = movie.poster.startsWith('http')
                    ? `<div class="match-poster-wrapper">
                        <img src="${escapeHtml(movie.poster)}" class="match-poster" alt="${escapeHtml(movie.title)}">
                        ${typeBadgeSmall}
                       </div>`
                    : `<div class="match-poster-wrapper">
                        <div class="match-poster" style="display: flex; align-items: center; justify-content: center; font-size: 40px;">${movie.poster}</div>
                        ${typeBadgeSmall}
                       </div>`;

                const isSelectedByYou = selectedMovieId === movie.id;
                const isSelectedByPartner = partnerSelectedMovieId === movie.id;

                let cardClass = 'match-card';
                if (isSelectedByYou) cardClass += ' selected-by-you';

                return `
                    <div class="${cardClass}" onclick="toggleMovieSelection(${movie.id})">
                        ${posterContent}
                        <div class="match-info">
                            <div class="match-title">${escapeHtml(movie.title)}</div>
                            <div class="match-description">${escapeHtml(movie.overview)}</div>
                            <div class="selection-indicators">
                                ${isSelectedByYou ? '<span class="selection-badge you">‚úì –í–∞—à –≤—ã–±–æ—Ä</span>' : ''}
                                ${isSelectedByPartner ? '<span class="selection-badge partner">‚úì –í—ã–±–æ—Ä –ø–∞—Ä—Ç–Ω–µ—Ä–∞</span>' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Determine message and button state
            let message = '';
            let buttonDisabled = true;

            if (!selectedMovieId) {
                message = '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫—É —Ñ–∏–ª—å–º–∞, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –µ–≥–æ.';
            } else if (!partnerSelectedMovieId) {
                message = '–ñ–¥—ë–º –ø–æ–∫–∞ –ø–∞—Ä—Ç–Ω–µ—Ä –≤—ã–±–µ—Ä–µ—Ç —Ñ–∏–ª—å–º...';
            } else if (bothSelectedSame) {
                message = '‚úì –û–±–∞ –≤—ã–±—Ä–∞–ª–∏ –æ–¥–∏–Ω —Ñ–∏–ª—å–º! –ú–æ–∂–µ—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä.';
                buttonDisabled = false;
            } else {
                message = '‚ö†Ô∏è –í—ã –≤—ã–±—Ä–∞–ª–∏ —Ä–∞–∑–Ω—ã–µ —Ñ–∏–ª—å–º—ã. –ò–∑–º–µ–Ω–∏—Ç–µ –≤—ã–±–æ—Ä, —á—Ç–æ–±—ã —Å–æ–≤–ø–∞–ª —Å –ø–∞—Ä—Ç–Ω–µ—Ä–æ–º.';
            }

            // Add confirmation button
            matchesGrid.innerHTML += `
                <div class="confirm-selection-container">
                    <div class="confirm-selection-info">
                        ${message}
                    </div>
                    <button class="btn" id="confirmBtn" onclick="confirmSelection()" ${buttonDisabled ? 'disabled' : ''}>
                        –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä
                    </button>
                </div>
            `;
        }

        function toggleMovieSelection(movieId) {
            if (isConfirmed) return; // Already confirmed, can't change

            // Toggle selection
            selectedMovieId = selectedMovieId === movieId ? null : movieId;

            // Immediately send selection to Firebase (real-time update)
            if (database && sessionId) {
                const selectionKey = isHost ? 'hostCurrentSelection' : 'partnerCurrentSelection';
                firebaseManager.write(`sessions/${sessionId}/${selectionKey}`, selectedMovieId)
                    .then((success) => {
                        if (success) {
                            console.log('Selection updated in Firebase:', selectedMovieId);
                        } else {
                            console.error('Error updating selection');
                        }
                    });
            }

            renderMatchesGrid();
        }

        function confirmSelection() {
            if (!selectedMovieId || isConfirmed) return;

            // Check that both selected the same movie
            if (selectedMovieId !== partnerSelectedMovieId) {
                alert('–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ä–∞–∑–Ω—ã–µ —Ñ–∏–ª—å–º—ã! –ò–∑–º–µ–Ω–∏—Ç–µ –≤—ã–±–æ—Ä, —á—Ç–æ–±—ã —Å–æ–≤–ø–∞–ª —Å –ø–∞—Ä—Ç–Ω–µ—Ä–æ–º.');
                return;
            }

            isConfirmed = true;

            // Update UI to show confirmation
            document.getElementById('confirmBtn').disabled = true;
            document.getElementById('confirmBtn').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–∞—Ä—Ç–Ω–µ—Ä–∞...';

            // Send confirmation to Firebase and wait for partner
            waitForPartnerConfirmation();
        }

        async function waitForPartnerConfirmation() {
            // Guard: prevent re-entry if we already moved past SELECTING
            if (currentSessionState !== SessionState.SELECTING) {
                console.log('waitForPartnerConfirmation() called but already in state:', currentSessionState, '- ignoring');
                return;
            }

            console.log('waitForPartnerConfirmation() - transitioning to WAITING_FOR_SELECTION');
            const transitioned = sessionManager.transitionTo(SessionState.WAITING_FOR_SELECTION);
            if (!transitioned) {
                console.error('Failed to transition to WAITING_FOR_SELECTION');
                return;
            }

            const movie = matchedMovies.find(m => m.id === selectedMovieId);
            if (!movie) {
                console.error('Selected movie not found!');
                return;
            }

            // Send confirmation to Firebase
            if (database && sessionId) {
                const confirmationKey = isHost ? 'hostConfirmed' : 'partnerConfirmed';
                await firebaseManager.write(`sessions/${sessionId}/${confirmationKey}`, true);
                console.log('Sent confirmation to Firebase');

                // Check if partner already confirmed
                const partnerConfirmationKey = isHost ? 'partnerConfirmed' : 'hostConfirmed';

                try {
                    const partnerConfirmed = await firebaseManager.read(`sessions/${sessionId}/${partnerConfirmationKey}`);

                    // If partner already confirmed, show final movie immediately
                    if (partnerConfirmed === true) {
                        console.log('Partner already confirmed! Showing final movie.');
                        showFinalChoice(movie);
                        return;
                    }
                } catch (error) {
                    console.error('Error checking partner confirmation:', error);
                }

                // Partner hasn't confirmed yet, wait for them
                let confirmationReceived = false;
                const partnerConfirmationRef = database.ref(`sessions/${sessionId}/${partnerConfirmationKey}`);
                const partnerConfirmationCallback = (snapshot) => {
                    const confirmed = snapshot.val();
                    if (confirmed === true && !confirmationReceived) {
                        confirmationReceived = true;
                        const listenerId = sessionManager.get('partnerConfirmationListenerId');
                        if (listenerId) {
                            firebaseManager.removeListener(listenerId);
                            sessionManager.set('partnerConfirmationListenerId', null);
                        }
                        console.log('Partner confirmed! Showing final movie.');
                        showFinalChoice(movie);
                    }
                };

                const listenerId = firebaseManager.addListener(partnerConfirmationRef, 'value', partnerConfirmationCallback);
                sessionManager.set('partnerConfirmationListenerId', listenerId);

                // Add timeout
                setTimeout(() => {
                    if (!confirmationReceived) {
                        confirmationReceived = true;
                        const listenerId = sessionManager.get('partnerConfirmationListenerId');
                        if (listenerId) {
                            firebaseManager.removeListener(listenerId);
                            sessionManager.set('partnerConfirmationListenerId', null);
                        }
                        alert('–í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–∞—Ä—Ç–Ω–µ—Ä–∞ –∏—Å—Ç–µ–∫–ª–æ.');
                        showFinalChoice(movie);
                    }
                }, 2 * 60 * 1000); // 2 minutes for confirmation
            } else {
                // Demo mode
                showFinalChoice(movie);
            }
        }

        function showFinalChoice(movie) {
            console.log('showFinalChoice() - transitioning to FINAL');
            sessionManager.transitionTo(SessionState.FINAL);

            // Clean up all remaining listeners - we're done!
            cleanupAllListeners();

            showScreen('finalScreen');

            // Content type info
            const contentType = movie.type || 'movie';
            const typeLabel = contentType === 'series' ? 'üì∫ –°–µ—Ä–∏–∞–ª' : 'üé¨ –§–∏–ª—å–º';
            const typeBadgeClass = contentType === 'series' ? 'series' : 'movie';

            const posterContent = movie.poster.startsWith('http')
                ? `<div class="final-poster-wrapper">
                    <img src="${escapeHtml(movie.poster)}" class="final-poster" alt="${escapeHtml(movie.title)}">
                    <div class="final-type-badge ${typeBadgeClass}">${typeLabel}</div>
                   </div>`
                : `<div style="font-size: 120px; margin-bottom: 20px;">${movie.poster}</div>`;

            document.getElementById('finalMovie').innerHTML = `
                ${posterContent}
                <h2 style="font-size: 28px; margin-bottom: 15px;">${escapeHtml(movie.title)}</h2>
                <p style="font-size: 16px; opacity: 0.9;">${escapeHtml(movie.overview)}</p>
            `;

            // Trigger confetti animation
            setTimeout(() => playConfetti(), 100);
        }

        // Confetti animation
        function playConfetti() {
            const canvas = document.createElement('canvas');
            canvas.style.position = 'fixed';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '999';
            document.body.appendChild(canvas);

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const ctx = canvas.getContext('2d');
            const confetti = [];
            const colors = ['#667eea', '#764ba2', '#2ed573', '#ff4757', '#ffd700', '#2196f3'];

            // Create confetti particles
            for (let i = 0; i < 150; i++) {
                confetti.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    r: Math.random() * 6 + 4,
                    d: Math.random() * 10 + 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    tilt: Math.random() * 10 - 5,
                    tiltAngleIncremental: Math.random() * 0.07 + 0.05,
                    tiltAngle: 0
                });
            }

            function drawConfetti() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                confetti.forEach((c, index) => {
                    ctx.beginPath();
                    ctx.lineWidth = c.r / 2;
                    ctx.strokeStyle = c.color;
                    ctx.moveTo(c.x + c.tilt + c.r, c.y);
                    ctx.lineTo(c.x + c.tilt, c.y + c.tilt + c.r);
                    ctx.stroke();

                    c.tiltAngle += c.tiltAngleIncremental;
                    c.y += (Math.cos(c.d) + 3 + c.r / 2) / 2;
                    c.x += Math.sin(c.d);
                    c.tilt = Math.sin(c.tiltAngle - index / 3) * 15;

                    if (c.y > canvas.height) {
                        confetti.splice(index, 1);
                    }
                });

                if (confetti.length > 0) {
                    requestAnimationFrame(drawConfetti);
                } else {
                    // Remove canvas when done
                    setTimeout(() => canvas.remove(), 100);
                }
            }

            drawConfetti();
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
            updateSessionCodeDisplay();
        }

        function updateSessionCodeDisplay() {
            if (!sessionId) return;

            // Update all session code displays
            const displays = [
                { element: 'sessionCodeLink', text: 'sessionCodeTextLink' },
                { element: 'sessionCodeDisplay', text: 'sessionCodeText' },
                { element: 'sessionCodeResults', text: 'sessionCodeTextResults' },
                { element: 'sessionCodeFinal', text: 'sessionCodeTextFinal' }
            ];

            displays.forEach(display => {
                const element = document.getElementById(display.element);
                const textElement = document.getElementById(display.text);
                if (element && textElement) {
                    element.style.display = 'block';
                    textElement.textContent = sessionId;
                }
            });
        }

        function generateSessionId() {
            return Math.random().toString(36).substring(2, 10);
        }

        // Toast notification system
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const icons = {
                success: '‚úì',
                error: '‚úó',
                info: '‚Ñπ'
            };

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${escapeHtml(message)}</span>
            `;

            container.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(20px)';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        function copyLink() {
            const link = document.getElementById('sessionLink').textContent;
            navigator.clipboard.writeText(link).then(() => {
                showToast('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!', 'success');
            }).catch(() => {
                showToast('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'error');
            });
        }

        function startOver() {
            // Clear session from localStorage before reload
            clearSessionStorage();
            location.reload();
        }

        // ============================================
        // localStorage Session Persistence
        // ============================================
        const SESSION_STORAGE_KEY = 'moviematch_session';

        function saveSessionToStorage() {
            try {
                const sessionData = {
                    sessionId: sessionId,
                    isHost: isHost,
                    movies: movies,
                    currentState: currentSessionState,
                    selectedGenres: selectedGenres,
                    selectedCountries: selectedCountries,
                    selectedLanguages: selectedLanguages,
                    minRating: minRating,
                    minYear: minYear,
                    movieCount: movieCount,
                    userChoices: userChoices,
                    partnerChoices: partnerChoices,
                    currentMovieIndex: currentMovieIndex,
                    matchedMovies: matchedMovies,
                    savedAt: Date.now()
                };
                localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(sessionData));
                console.log('Session saved to localStorage:', sessionId);
            } catch (error) {
                console.error('Error saving session to localStorage:', error);
            }
        }

        function loadSessionFromStorage() {
            try {
                const stored = localStorage.getItem(SESSION_STORAGE_KEY);
                if (!stored) return null;

                const sessionData = JSON.parse(stored);

                // Check if session is not too old (expire after 24 hours)
                const age = Date.now() - sessionData.savedAt;
                const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                if (age > maxAge) {
                    console.log('Stored session expired, clearing...');
                    clearSessionStorage();
                    return null;
                }

                console.log('Loaded session from localStorage:', sessionData.sessionId);
                return sessionData;
            } catch (error) {
                console.error('Error loading session from localStorage:', error);
                return null;
            }
        }

        function clearSessionStorage() {
            try {
                localStorage.removeItem(SESSION_STORAGE_KEY);
                console.log('Cleared session from localStorage');
            } catch (error) {
                console.error('Error clearing session from localStorage:', error);
            }
        }

        function restoreSession(sessionData) {
            console.log('Restoring session from localStorage...');

            // Restore all session variables
            sessionId = sessionData.sessionId;
            isHost = sessionData.isHost;
            movies = sessionData.movies || [];
            currentSessionState = sessionData.currentState || SessionState.SETUP;
            selectedGenres = sessionData.selectedGenres || [];
            selectedCountries = sessionData.selectedCountries || [];
            selectedLanguages = sessionData.selectedLanguages || ['rus', 'eng'];
            minRating = sessionData.minRating || 7.0;
            minYear = sessionData.minYear || 1970;
            movieCount = sessionData.movieCount || 20;
            userChoices = sessionData.userChoices || {};
            partnerChoices = sessionData.partnerChoices || {};
            currentMovieIndex = sessionData.currentMovieIndex || 0;
            matchedMovies = sessionData.matchedMovies || [];

            // Update SessionManager
            sessionManager.setState(currentSessionState);
            sessionManager.set('sessionId', sessionId);
            sessionManager.set('isHost', isHost);

            // Update URL with session parameter if not already present
            const urlParams = new URLSearchParams(window.location.search);
            if (!urlParams.get('session')) {
                const newUrl = `${window.location.pathname}?session=${sessionId}`;
                window.history.replaceState({ sessionId: sessionId }, '', newUrl);
                console.log('Updated URL with restored session:', newUrl);
            }

            // Restore appropriate screen based on state
            if (currentSessionState === SessionState.SWIPING) {
                console.log('Restoring swipe screen...');
                startSwipePhase();
            } else if (currentSessionState === SessionState.SELECTING) {
                console.log('Restoring results screen...');
                showMatches();
            } else if (currentSessionState === SessionState.FINAL) {
                console.log('Restoring final screen...');
                // The final movie should be in matchedMovies[0] or we need to recalculate
                if (matchedMovies.length > 0) {
                    displayFinalChoice(matchedMovies[0]);
                }
            } else {
                console.log('Restoring setup screen...');
                showScreen('setupScreen');
            }

            console.log('Session restored successfully');
        }

        // Movie modal functions
        function showMovieModal(movieId) {
            // Try to find movie in matched movies first (if on results screen), otherwise in all movies
            const movie = matchedMovies.find(m => m.id === movieId) || movies.find(m => m.id === movieId);
            if (!movie) return;

            const modal = document.getElementById('movieModal');
            const modalDetails = document.getElementById('modalMovieDetails');

            // Language badges
            const languageBadges = movie.languages && movie.languages.length > 0
                ? `<div class="modal-languages">
                    ${movie.languages.map(lang => `<span class="modal-language-badge ${lang}">${lang}</span>`).join('')}
                   </div>`
                : '';

            const posterContent = movie.poster.startsWith('http')
                ? `<div class="modal-poster">
                    <img src="${escapeHtml(movie.poster)}" alt="${escapeHtml(movie.title)}">
                    ${languageBadges}
                    ${movie.rating !== 'N/A' ? `<div class="modal-rating">‚≠ê ${escapeHtml(movie.rating)}</div>` : ''}
                   </div>`
                : `<div class="modal-poster" style="display: flex; align-items: center; justify-content: center; font-size: 120px;">${movie.poster}</div>`;

            const genresHtml = movie.movieGenres && movie.movieGenres.length > 0
                ? `<div class="modal-genres">${movie.movieGenres.map(g => `<span class="modal-genre">${escapeHtml(g)}</span>`).join('')}</div>`
                : '';

            const metaHtml = `
                <div class="modal-meta">
                    ${movie.year !== 'N/A' ? `<span>üìÖ ${escapeHtml(movie.year)}</span>` : ''}
                    ${movie.director !== '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω' ? `<span>üé¨ ${escapeHtml(movie.director)}</span>` : ''}
                </div>
            `;

            // Show "Select this movie" button only if we're on results screen and not yet confirmed
            const showSelectButton = matchedMovies.length > 0 && !isConfirmed;

            modalDetails.innerHTML = `
                ${posterContent}
                <div class="modal-body">
                    <div class="modal-title">${escapeHtml(movie.title)}</div>
                    ${metaHtml}
                    ${genresHtml}
                    <div class="modal-description">${escapeHtml(movie.overview)}</div>
                    ${showSelectButton ? `<button class="btn" onclick="selectMovieFromModal(${movie.id})">–í—ã–±—Ä–∞—Ç—å —ç—Ç–æ—Ç —Ñ–∏–ª—å–º</button>` : ''}
                </div>
            `;

            modal.classList.add('active');
        }

        function closeMovieModal(event) {
            // Close only if clicking on overlay or explicit close
            if (!event || event.target.id === 'movieModal' || event.target.classList.contains('modal-close')) {
                document.getElementById('movieModal').classList.remove('active');
            }
        }

        function selectMovieFromModal(movieId) {
            closeMovieModal();
            toggleMovieSelection(movieId);
        }

        // Initialize app
        document.getElementById('createSessionBtn').onclick = createSession;

        // Try to restore session from localStorage first
        const storedSession = loadSessionFromStorage();
        const urlParams = new URLSearchParams(window.location.search);
        const sessionParam = urlParams.get('session');

        if (storedSession && storedSession.sessionId) {
            // Restore session from localStorage
            console.log('Found stored session, restoring...', storedSession.sessionId);

            // Wait for Firebase if needed
            if (database) {
                (async () => {
                    try {
                        await waitForFirebase();
                        restoreSession(storedSession);
                        // Reconnect to Firebase listeners if in active session
                        if (storedSession.currentState !== SessionState.SETUP) {
                            console.log('Reconnecting Firebase listeners for restored session...');
                            // The restoreSession function handles screen restoration
                        }
                    } catch (error) {
                        console.error('Error restoring session:', error);
                        clearSessionStorage();
                        initializeUI();
                    }
                })();
            } else {
                restoreSession(storedSession);
            }
        } else if (sessionParam) {
            // No stored session, but URL has session parameter - joining from link
            sessionId = sessionParam;
            console.log('Joining session from URL:', sessionId);

            // Wait for Firebase to initialize before joining
            (async () => {
                try {
                    console.log('Waiting for Firebase to initialize...');
                    await waitForFirebase();
                    console.log('Firebase ready, joining session');
                    await joinSession(sessionId);
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                    alert('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Firebase: ' + error.message + '\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.');
                    window.location.href = window.location.pathname;
                }
            })();
        } else {
            // No stored session and no URL parameter - fresh start
            console.log('Starting fresh session');
            initializeUI();
        }
    </script>
</body>
</html>
