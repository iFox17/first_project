<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MovieMatch - –í—ã–±–∏—Ä–∞–µ–º —Ñ–∏–ª—å–º –≤–¥–≤–æ–µ–º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg,
                rgba(102, 126, 234, 0.3) 0%,
                rgba(118, 75, 162, 0.3) 25%,
                rgba(233, 30, 99, 0.3) 50%,
                rgba(118, 75, 162, 0.3) 75%,
                rgba(102, 126, 234, 0.3) 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            padding: 30px 0;
        }

        .logo {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.4);
            letter-spacing: 0.5px;
            line-height: 1.2;
        }

        .header p {
            font-size: 16px;
            opacity: 0.9;
            line-height: 1.5;
            letter-spacing: 0.3px;
        }

        .screen {
            display: none;
            flex-direction: column;
            flex: 1;
        }

        .screen.active {
            display: flex;
        }

        /* Setup Screen */
        .setup-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-top: 20px;
        }

        .setup-section {
            margin-bottom: 30px;
        }

        .setup-section h3 {
            font-size: 18px;
            margin-bottom: 15px;
            opacity: 0.95;
            font-weight: 600;
            letter-spacing: 0.3px;
            line-height: 1.4;
        }

        .slider-container {
            margin-bottom: 10px;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: none;
        }

        .slider-value {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
        }

        .genre-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        @media (min-width: 640px) {
            .genre-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .genre-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid transparent;
            color: #fff;
            padding: 20px 12px;
            min-height: 80px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            font-size: 13px;
            font-weight: 500;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            line-height: 1.3;
        }

        .genre-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-3px) scale(1.03);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        .genre-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .genre-btn.selected {
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            border-color: #fff;
            font-weight: bold;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
            transform: scale(1.05);
        }

        .genre-btn.selected:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-3px) scale(1.08);
        }

        .btn {
            width: 100%;
            background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);
            color: #667eea;
            border: none;
            padding: 18px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            margin-top: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
            background: linear-gradient(135deg, #fff 0%, #fff 100%);
        }

        .btn:active {
            transform: translateY(-1px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Swipe Screen */
        .session-code {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            margin-bottom: 15px;
        }

        .session-code strong {
            opacity: 0.7;
            font-weight: 600;
        }

        /* Session code on swipe screen - absolute positioning */
        .swipe-screen .session-code {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 10;
            margin-bottom: 0;
        }

        .swipe-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            padding: 20px 0;
        }

        .swipe-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            gap: 15px;
        }

        .selected-genres {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 13px;
        }

        .selected-genres strong {
            display: block;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .genre-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .genre-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 11px;
        }

        .movies-counter {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            text-align: center;
            min-width: 100px;
        }

        .counter-value {
            font-size: 24px;
            font-weight: bold;
            display: block;
        }

        .counter-label {
            font-size: 11px;
            opacity: 0.8;
        }

        .partner-status {
            background: rgba(46, 213, 115, 0.2);
            border: 1px solid rgba(46, 213, 115, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            display: none;
        }

        .partner-status.show {
            display: block;
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 12px;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #764ba2 0%, #e91e63 50%, #667eea 100%);
            border-radius: 10px;
            transition: width 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(233, 30, 99, 0.3);
        }

        .card-stack {
            position: relative;
            width: 100%;
            height: 75vh;
            max-height: 600px;
            margin-bottom: 30px;
        }

        @media (min-width: 640px) and (max-width: 1024px) {
            .card-stack {
                height: 70vh;
            }
        }

        @media (min-width: 1024px) {
            .card-stack {
                height: 600px;
            }
        }

        .movie-card {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #fff;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            cursor: grab;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1),
                        box-shadow 0.3s ease;
        }

        .movie-card:hover {
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
        }

        .movie-card:active {
            cursor: grabbing;
        }

        .movie-card.swiping {
            transition: none;
        }

        .movie-poster {
            width: 100%;
            height: 65%;
            object-fit: cover;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 100px;
            position: relative;
        }

        .movie-poster img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .movie-rating {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            color: #ffd700;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .language-badges {
            position: absolute;
            bottom: 12px;
            left: 12px;
            display: flex;
            gap: 6px;
        }

        .language-badge {
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(6px);
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .language-badge.rus {
            background: rgba(33, 150, 243, 0.9);
        }

        .language-badge.eng {
            background: rgba(244, 67, 54, 0.9);
        }

        .movie-info {
            padding: 16px;
            color: #333;
            height: 35%;
            overflow-y: auto;
        }

        .movie-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 8px;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .movie-meta {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #888;
            flex-wrap: wrap;
        }

        .movie-meta span {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .movie-genres {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .movie-genre {
            background: #667eea;
            color: #fff;
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 11px;
        }

        .movie-description {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .swipe-buttons {
            display: flex;
            justify-content: center;
            gap: 40px;
        }

        .swipe-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            font-size: 36px;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.4, 0.0, 0.2, 1),
                        box-shadow 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        .swipe-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
        }

        .swipe-btn:active {
            transform: scale(0.95);
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.2);
        }

        .dislike-btn {
            background: #ff4757;
        }

        .like-btn {
            background: #2ed573;
        }

        .swipe-indicator {
            position: absolute;
            top: 50%;
            transform: translateY(-50%) scale(0.8);
            font-size: 80px;
            font-weight: bold;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            pointer-events: none;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .swipe-indicator.left {
            left: 30px;
            color: #ff4757;
        }

        .swipe-indicator.right {
            right: 30px;
            color: #2ed573;
        }

        .swipe-indicator.visible {
            opacity: 0.9;
            transform: translateY(-50%) scale(1);
        }

        /* Results Screen */
        .results-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .results-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .results-header h2 {
            font-size: 28px;
            margin-bottom: 10px;
            font-weight: bold;
            letter-spacing: 0.5px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
        }

        .matches-grid {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }

        .match-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            display: flex;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            border: 2px solid transparent;
        }

        .match-card:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .match-card:active {
            transform: translateY(-2px) scale(1);
        }

        .match-poster {
            width: 80px;
            height: 120px;
            border-radius: 10px;
            object-fit: cover;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .match-info {
            flex: 1;
        }

        .match-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .match-description {
            font-size: 14px;
            opacity: 0.85;
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            word-wrap: break-word;
        }

        .selection-indicators {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .selection-badge {
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .selection-badge.you {
            background: rgba(46, 213, 115, 0.3);
            border: 2px solid rgba(46, 213, 115, 0.8);
            color: #fff;
        }

        .selection-badge.partner {
            background: rgba(33, 150, 243, 0.3);
            border: 2px solid rgba(33, 150, 243, 0.8);
            color: #fff;
        }

        .match-card.selected-by-you {
            border-color: rgba(46, 213, 115, 0.8);
            box-shadow: 0 0 20px rgba(46, 213, 115, 0.3);
        }

        .confirm-selection-container {
            position: sticky;
            bottom: 20px;
            margin-top: 20px;
            text-align: center;
        }

        .confirm-selection-info {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .waiting-message {
            text-align: center;
            padding: 40px;
            font-size: 18px;
        }

        .loader {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid #fff;
            border-right: 4px solid rgba(233, 30, 99, 0.8);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite,
                       pulse 2s ease-in-out infinite;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        @keyframes spin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .session-info {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .session-link {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
            word-break: break-all;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .session-link:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: scale(1.02);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .session-link:active {
            transform: scale(0.98);
        }

        .final-choice {
            text-align: center;
            padding: 40px;
        }

        .final-movie {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-top: 20px;
        }

        .final-poster {
            width: 100%;
            max-width: 300px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        /* Toast Notifications */
        #toastContainer {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
        }

        .toast {
            background: rgba(33, 33, 33, 0.95);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 280px;
            max-width: 400px;
            animation: toastSlideUp 0.3s ease-out;
            pointer-events: auto;
        }

        .toast.success {
            background: rgba(46, 213, 115, 0.95);
        }

        .toast.error {
            background: rgba(255, 71, 87, 0.95);
        }

        .toast.info {
            background: rgba(33, 150, 243, 0.95);
        }

        @keyframes toastSlideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .toast-icon {
            font-size: 20px;
        }

        .toast-message {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
        }

        /* Movie Details Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: #fff;
            border-radius: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
            position: relative;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(0, 0, 0, 1);
            transform: scale(1.1);
        }

        .modal-poster {
            width: 100%;
            height: 400px;
            object-fit: cover;
            border-radius: 20px 20px 0 0;
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .modal-poster img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 20px 20px 0 0;
        }

        .modal-rating {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            color: #ffd700;
            padding: 10px 16px;
            border-radius: 12px;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .modal-languages {
            position: absolute;
            bottom: 15px;
            left: 15px;
            display: flex;
            gap: 8px;
        }

        .modal-language-badge {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            color: #fff;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        }

        .modal-language-badge.rus {
            background: rgba(33, 150, 243, 0.95);
        }

        .modal-language-badge.eng {
            background: rgba(244, 67, 54, 0.95);
        }

        .modal-body {
            padding: 30px;
            color: #333;
        }

        .modal-title {
            font-size: 26px;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
            color: #212121;
        }

        .modal-meta {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #757575;
            flex-wrap: wrap;
        }

        .modal-meta span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .modal-genres {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .modal-genre {
            background: #667eea;
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
        }

        .modal-description {
            font-size: 15px;
            color: #424242;
            line-height: 1.7;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="toastContainer"></div>

    <!-- Movie Details Modal -->
    <div class="modal-overlay" id="movieModal" onclick="closeMovieModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeMovieModal()">‚úï</button>
            <div id="modalMovieDetails"></div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <div class="logo">üé¨</div>
            <h1>MovieMatch</h1>
            <p>–í—ã–±–∏—Ä–∞–µ–º —Ñ–∏–ª—å–º –≤–¥–≤–æ–µ–º</p>
        </div>

        <!-- Setup Screen -->
        <div class="screen active" id="setupScreen">
            <div class="setup-container">
                <div class="setup-section">
                    <h3>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∏–ª—å–º–æ–≤</h3>
                    <div class="slider-container">
                        <input type="range" min="10" max="100" value="20" class="slider" id="movieCountSlider">
                        <div class="slider-value" id="movieCountValue">20</div>
                    </div>
                </div>

                <div class="setup-section">
                    <h3>–í—ã–±–µ—Ä–∏—Ç–µ –∂–∞–Ω—Ä—ã</h3>
                    <div class="genre-grid" id="genreGrid">
                        <!-- Genres will be added dynamically -->
                    </div>
                </div>

                <div class="setup-section">
                    <h3>–°—Ç—Ä–∞–Ω—ã –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞</h3>
                    <div class="genre-grid" id="countryGrid">
                        <!-- Countries will be added dynamically -->
                    </div>
                </div>

                <div class="setup-section">
                    <h3>–ù–µ —Ä–∞–Ω—å—à–µ –∫–∞–∫–æ–≥–æ –≥–æ–¥–∞</h3>
                    <div class="slider-container">
                        <input type="range" min="1970" max="2025" value="2000" class="slider" id="yearSlider">
                        <div class="slider-value" id="yearValue">2000</div>
                    </div>
                </div>

                <button class="btn" id="createSessionBtn">–°–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é</button>
            </div>
        </div>

        <!-- Session Link Screen -->
        <div class="screen" id="linkScreen">
            <div class="session-code" id="sessionCodeLink" style="display: none;">
                <strong>–ö–æ–¥ —Å–µ—Å—Å–∏–∏:</strong> <span id="sessionCodeTextLink"></span>
            </div>
            <div class="session-info">
                <h2>–°–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞!</h2>
                <p>–û—Ç–ø—Ä–∞–≤—å—Ç–µ —ç—Ç—É —Å—Å—ã–ª–∫—É –≤—Ç–æ—Ä–æ–º—É —á–µ–ª–æ–≤–µ–∫—É:</p>
                <div class="session-link" id="sessionLink" onclick="copyLink()">
                    <!-- Link will be generated -->
                </div>
                <p style="margin-top: 15px; font-size: 14px; opacity: 0.8;">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Å—Å—ã–ª–∫—É, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</p>
            </div>
            <div class="waiting-message">
                <div class="loader"></div>
                <p>–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤—Ç–æ—Ä–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞...</p>
            </div>
        </div>

        <!-- Swipe Screen -->
        <div class="screen" id="swipeScreen">
            <div class="session-code" id="sessionCodeDisplay" style="display: none;">
                <strong>–ö–æ–¥:</strong> <span id="sessionCodeText"></span>
            </div>
            <div class="swipe-container">
                <div class="swipe-info">
                    <div class="selected-genres" id="selectedGenresDisplay">
                        <strong>–ñ–∞–Ω—Ä—ã:</strong>
                        <div class="genre-tags" id="genreTags"></div>
                    </div>
                    <div class="movies-counter">
                        <span class="counter-value" id="moviesRemaining">0</span>
                        <span class="counter-label">–æ—Å—Ç–∞–ª–æ—Å—å</span>
                    </div>
                </div>

                <div class="partner-status" id="partnerStatus">
                    ‚úì –ü–∞—Ä—Ç–Ω–µ—Ä –∑–∞–∫–æ–Ω—á–∏–ª –ø—Ä–æ—Å–º–æ—Ç—Ä
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>

                <div class="card-stack" id="cardStack">
                    <div class="swipe-indicator left" id="dislikeIndicator">‚úó</div>
                    <div class="swipe-indicator right" id="likeIndicator">‚ô•</div>
                    <!-- Movie cards will be added dynamically -->
                </div>

                <div class="swipe-buttons">
                    <button class="swipe-btn dislike-btn" onclick="swipe('dislike')">‚úó</button>
                    <button class="swipe-btn like-btn" onclick="swipe('like')">‚ô•</button>
                </div>
            </div>
        </div>

        <!-- Results Screen -->
        <div class="screen" id="resultsScreen">
            <div class="session-code" id="sessionCodeResults" style="display: none;">
                <strong>–ö–æ–¥ —Å–µ—Å—Å–∏–∏:</strong> <span id="sessionCodeTextResults"></span>
            </div>
            <div class="results-container">
                <div class="results-header">
                    <h2>–°–æ–≤–ø–∞–¥–µ–Ω–∏—è!</h2>
                    <p>–í—ã –æ–±–∞ –≤—ã–±—Ä–∞–ª–∏ —ç—Ç–∏ —Ñ–∏–ª—å–º—ã</p>
                </div>
                <div class="matches-grid" id="matchesGrid">
                    <!-- Matches will be added dynamically -->
                </div>
            </div>
        </div>

        <!-- Final Choice Screen -->
        <div class="screen" id="finalScreen">
            <div class="session-code" id="sessionCodeFinal" style="display: none;">
                <strong>–ö–æ–¥ —Å–µ—Å—Å–∏–∏:</strong> <span id="sessionCodeTextFinal"></span>
            </div>
            <div class="final-choice">
                <h2>–í–∞—à –≤—ã–±–æ—Ä:</h2>
                <div class="final-movie" id="finalMovie">
                    <!-- Final movie will be displayed -->
                </div>
                <button class="btn" onclick="startOver()">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
            </div>
        </div>
    </div>

    <script>
        // TMDB API Configuration
        const TMDB_API_KEY = 'fa372a103e830cd8e937e23614f75c39';
        const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
        const TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p/w500';

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBQnA0C5Ouf9pC3El_GXX0_aLAcFaYT2Co",
            authDomain: "filmmatching-8a8bf.firebaseapp.com",
            databaseURL: "https://filmmatching-8a8bf-default-rtdb.firebaseio.com",
            projectId: "filmmatching-8a8bf",
            storageBucket: "filmmatching-8a8bf.firebasestorage.app",
            messagingSenderId: "104378741912",
            appId: "1:104378741912:web:aefae82ff333922aef0ced",
            measurementId: "G-41PV9QGCRM"
        };

        // Initialize Firebase
        let database = null;
        let useFirebase = false;
        let firebaseInitPromise = null;

        // Promise-based Firebase initialization
        if (firebaseConfig.apiKey !== "YOUR_API_KEY") {
            firebaseInitPromise = new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                    reject(new Error('Firebase initialization timeout'));
                }, 15000); // 15 second timeout

                const script1 = document.createElement('script');
                script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
                script1.onerror = () => {
                    clearTimeout(timeoutId);
                    reject(new Error('Failed to load Firebase App SDK'));
                };
                script1.onload = () => {
                    const script2 = document.createElement('script');
                    script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js';
                    script2.onerror = () => {
                        clearTimeout(timeoutId);
                        reject(new Error('Failed to load Firebase Database SDK'));
                    };
                    script2.onload = () => {
                        try {
                            firebase.initializeApp(firebaseConfig);
                            database = firebase.database();
                            useFirebase = true;
                            clearTimeout(timeoutId);
                            console.log('Firebase –ø–æ–¥–∫–ª—é—á–µ–Ω');
                            resolve(database);
                        } catch (error) {
                            clearTimeout(timeoutId);
                            console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Firebase:', error);
                            reject(error);
                        }
                    };
                    document.head.appendChild(script2);
                };
                document.head.appendChild(script1);
            });
        } else {
            console.log('Firebase –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –†–∞–±–æ—Ç–∞–µ—Ç –≤ –¥–µ–º–æ-—Ä–µ–∂–∏–º–µ (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è).');
            firebaseInitPromise = Promise.reject(new Error('Firebase not configured'));
        }

        // Helper to wait for Firebase
        async function waitForFirebase(timeout = 15000) {
            if (!firebaseInitPromise) {
                throw new Error('Firebase not configured');
            }
            try {
                await firebaseInitPromise;
                return database;
            } catch (error) {
                throw error;
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') {
                return unsafe;
            }
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Validate Firebase session data
        function validateSessionData(sessionData) {
            if (!sessionData || typeof sessionData !== 'object') {
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö —Å–µ—Å—Å–∏–∏');
            }

            // Validate genres
            if (!Array.isArray(sessionData.genres) || sessionData.genres.length === 0) {
                throw new Error('–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–µ –∂–∞–Ω—Ä—ã');
            }

            // Validate all genre IDs are numbers
            if (!sessionData.genres.every(id => typeof id === 'number')) {
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID –∂–∞–Ω—Ä–æ–≤');
            }

            // Validate countries (optional)
            if (sessionData.countries !== undefined && !Array.isArray(sessionData.countries)) {
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Ç—Ä–∞–Ω');
            }

            // Validate movieCount
            if (typeof sessionData.movieCount !== 'number' ||
                sessionData.movieCount < 10 ||
                sessionData.movieCount > 100) {
                throw new Error('–ù–µ–≤–µ—Ä–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∏–ª—å–º–æ–≤ (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 10-100)');
            }

            // Validate minYear
            if (typeof sessionData.minYear !== 'number' ||
                sessionData.minYear < 1970 ||
                sessionData.minYear > 2025) {
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π –≥–æ–¥ (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 1970-2025)');
            }

            return true;
        }

        // Available genres
        const genres = [
            { id: 28, name: '–ë–æ–µ–≤–∏–∫' },
            { id: 35, name: '–ö–æ–º–µ–¥–∏—è' },
            { id: 18, name: '–î—Ä–∞–º–∞' },
            { id: 27, name: '–£–∂–∞—Å—ã' },
            { id: 10749, name: '–ú–µ–ª–æ–¥—Ä–∞–º–∞' },
            { id: 878, name: '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞' },
            { id: 53, name: '–¢—Ä–∏–ª–ª–µ—Ä' },
            { id: 16, name: '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º' }
        ];

        // Available countries (ISO 3166-1)
        const countries = [
            { code: 'US', name: '–°–®–ê' },
            { code: 'GB', name: '–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è' },
            { code: 'FR', name: '–§—Ä–∞–Ω—Ü–∏—è' },
            { code: 'DE', name: '–ì–µ—Ä–º–∞–Ω–∏—è' },
            { code: 'IT', name: '–ò—Ç–∞–ª–∏—è' },
            { code: 'ES', name: '–ò—Å–ø–∞–Ω–∏—è' },
            { code: 'RU', name: '–†–æ—Å—Å–∏—è' },
            { code: 'JP', name: '–Ø–ø–æ–Ω–∏—è' },
            { code: 'KR', name: '–ö–æ—Ä–µ—è' },
            { code: 'CN', name: '–ö–∏—Ç–∞–π' }
        ];

        // ============================================
        // ARCHITECTURE: Centralized State Management
        // ============================================

        // Session State Machine
        const SessionState = {
            SETUP: 'setup',
            SWIPING: 'swiping',
            WAITING_FOR_MATCHES: 'waiting_for_matches',
            SELECTING: 'selecting',
            WAITING_FOR_SELECTION: 'waiting_for_selection',
            FINAL: 'final'
        };

        // Valid state transitions for safety
        const VALID_TRANSITIONS = {
            [SessionState.SETUP]: [SessionState.SWIPING],
            [SessionState.SWIPING]: [SessionState.WAITING_FOR_MATCHES],
            [SessionState.WAITING_FOR_MATCHES]: [SessionState.SELECTING, SessionState.FINAL],
            [SessionState.SELECTING]: [SessionState.WAITING_FOR_SELECTION],
            [SessionState.WAITING_FOR_SELECTION]: [SessionState.FINAL],
            [SessionState.FINAL]: []
        };

        // ============================================
        // Firebase Manager - Centralized Firebase Operations
        // ============================================
        class FirebaseManager {
            constructor() {
                this.listeners = new Map(); // listener_id -> {ref, eventType, callback}
                this.listenerCounter = 0;
            }

            addListener(ref, eventType, callback) {
                if (!database) return null;

                const listenerId = `listener_${this.listenerCounter++}`;
                ref.on(eventType, callback);
                this.listeners.set(listenerId, { ref, eventType, callback });
                console.log(`[Firebase] Listener added: ${listenerId} (total: ${this.listeners.size})`);
                return listenerId;
            }

            removeListener(listenerId) {
                if (!this.listeners.has(listenerId)) return false;

                const { ref, eventType, callback } = this.listeners.get(listenerId);
                ref.off(eventType, callback);
                this.listeners.delete(listenerId);
                console.log(`[Firebase] Listener removed: ${listenerId} (remaining: ${this.listeners.size})`);
                return true;
            }

            removeAllListeners() {
                console.log(`[Firebase] Removing all listeners (${this.listeners.size})`);
                this.listeners.forEach(({ ref, eventType, callback }) => {
                    ref.off(eventType, callback);
                });
                this.listeners.clear();
            }

            async write(path, data) {
                if (!database) return false;
                try {
                    await database.ref(path).set(data);
                    console.log(`[Firebase] Write success: ${path}`, data);
                    return true;
                } catch (error) {
                    console.error(`[Firebase] Write error: ${path}`, error);
                    return false;
                }
            }

            async update(path, data) {
                if (!database) return false;
                try {
                    await database.ref(path).update(data);
                    console.log(`[Firebase] Update success: ${path}`, data);
                    return true;
                } catch (error) {
                    console.error(`[Firebase] Update error: ${path}`, error);
                    return false;
                }
            }

            async read(path) {
                if (!database) return null;
                try {
                    const snapshot = await database.ref(path).once('value');
                    const data = snapshot.val();
                    console.log(`[Firebase] Read success: ${path}`, data);
                    return data;
                } catch (error) {
                    console.error(`[Firebase] Read error: ${path}`, error);
                    return null;
                }
            }

            getHealthStatus() {
                return {
                    connected: !!database,
                    activeListeners: this.listeners.size,
                    listenerIds: Array.from(this.listeners.keys())
                };
            }
        }

        // ============================================
        // Session Manager - Centralized State Management
        // ============================================
        class SessionManager {
            constructor() {
                this.state = SessionState.SETUP;
                this.data = {
                    sessionId: null,
                    isHost: false,
                    selectedGenres: [],
                    selectedCountries: [],
                    movieCount: 20,
                    minYear: 2000,
                    movies: [],
                    currentMovieIndex: 0,
                    userChoices: {},
                    partnerChoices: {},
                    matchedMovies: [],
                    selectedMovieId: null,
                    partnerSelectedMovieId: null,
                    isConfirmed: false
                };
                this.eventHandlers = new Map(); // event -> [callbacks]
                this.stateHistory = []; // For debugging
            }

            // State management with validation
            transitionTo(newState) {
                const currentState = this.state;

                if (!VALID_TRANSITIONS[currentState] || !VALID_TRANSITIONS[currentState].includes(newState)) {
                    console.error(`[SessionManager] Invalid transition: ${currentState} -> ${newState}`);
                    this.logHealthCheck();
                    return false;
                }

                console.log(`[SessionManager] State transition: ${currentState} -> ${newState}`);
                this.stateHistory.push({ from: currentState, to: newState, timestamp: Date.now() });
                this.state = newState;
                this.emit('stateChange', { from: currentState, to: newState });
                return true;
            }

            // Event system for coordination
            on(eventName, callback) {
                if (!this.eventHandlers.has(eventName)) {
                    this.eventHandlers.set(eventName, []);
                }
                this.eventHandlers.get(eventName).push(callback);
            }

            emit(eventName, data) {
                const handlers = this.eventHandlers.get(eventName) || [];
                handlers.forEach(callback => {
                    try {
                        callback(data);
                    } catch (error) {
                        console.error(`[SessionManager] Event handler error (${eventName}):`, error);
                    }
                });
            }

            // Data access
            get(key) {
                return this.data[key];
            }

            set(key, value) {
                const oldValue = this.data[key];
                this.data[key] = value;
                console.log(`[SessionManager] Data updated: ${key}`, { old: oldValue, new: value });
                this.emit('dataChange', { key, oldValue, newValue: value });
            }

            // Batch update for related data
            update(updates) {
                Object.entries(updates).forEach(([key, value]) => {
                    this.set(key, value);
                });
            }

            // Health check for debugging
            logHealthCheck() {
                console.log('[SessionManager] Health Check:', {
                    state: this.state,
                    sessionId: this.data.sessionId,
                    isHost: this.data.isHost,
                    movieCount: this.data.movies.length,
                    currentIndex: this.data.currentMovieIndex,
                    choicesCount: Object.keys(this.data.userChoices).length,
                    partnerChoicesCount: Object.keys(this.data.partnerChoices).length,
                    stateHistory: this.stateHistory.slice(-5)
                });
            }

            // Reset session
            reset() {
                console.log('[SessionManager] Resetting session');
                this.state = SessionState.SETUP;
                this.data = {
                    sessionId: null,
                    isHost: false,
                    selectedGenres: [],
                    selectedCountries: [],
                    movieCount: 20,
                    minYear: 2000,
                    movies: [],
                    currentMovieIndex: 0,
                    userChoices: {},
                    partnerChoices: {},
                    matchedMovies: [],
                    selectedMovieId: null,
                    partnerSelectedMovieId: null,
                    isConfirmed: false
                };
                this.stateHistory = [];
                this.emit('reset');
            }
        }

        // ============================================
        // Initialize Managers
        // ============================================
        const firebaseManager = new FirebaseManager();
        const sessionManager = new SessionManager();

        // Legacy compatibility - proxy to SessionManager
        let currentCardCleanup = null;

        // Proxy getters/setters for backward compatibility
        Object.defineProperty(window, 'sessionId', {
            get: () => sessionManager.get('sessionId'),
            set: (value) => sessionManager.set('sessionId', value)
        });
        Object.defineProperty(window, 'isHost', {
            get: () => sessionManager.get('isHost'),
            set: (value) => sessionManager.set('isHost', value)
        });
        Object.defineProperty(window, 'selectedGenres', {
            get: () => sessionManager.get('selectedGenres'),
            set: (value) => sessionManager.set('selectedGenres', value)
        });
        Object.defineProperty(window, 'selectedCountries', {
            get: () => sessionManager.get('selectedCountries'),
            set: (value) => sessionManager.set('selectedCountries', value)
        });
        Object.defineProperty(window, 'movieCount', {
            get: () => sessionManager.get('movieCount'),
            set: (value) => sessionManager.set('movieCount', value)
        });
        Object.defineProperty(window, 'minYear', {
            get: () => sessionManager.get('minYear'),
            set: (value) => sessionManager.set('minYear', value)
        });
        Object.defineProperty(window, 'movies', {
            get: () => sessionManager.get('movies'),
            set: (value) => sessionManager.set('movies', value)
        });
        Object.defineProperty(window, 'currentMovieIndex', {
            get: () => sessionManager.get('currentMovieIndex'),
            set: (value) => sessionManager.set('currentMovieIndex', value)
        });
        Object.defineProperty(window, 'userChoices', {
            get: () => sessionManager.get('userChoices'),
            set: (value) => sessionManager.set('userChoices', value)
        });
        Object.defineProperty(window, 'partnerChoices', {
            get: () => sessionManager.get('partnerChoices'),
            set: (value) => sessionManager.set('partnerChoices', value)
        });
        Object.defineProperty(window, 'matchedMovies', {
            get: () => sessionManager.get('matchedMovies'),
            set: (value) => sessionManager.set('matchedMovies', value)
        });
        Object.defineProperty(window, 'selectedMovieId', {
            get: () => sessionManager.get('selectedMovieId'),
            set: (value) => sessionManager.set('selectedMovieId', value)
        });
        Object.defineProperty(window, 'partnerSelectedMovieId', {
            get: () => sessionManager.get('partnerSelectedMovieId'),
            set: (value) => sessionManager.set('partnerSelectedMovieId', value)
        });
        Object.defineProperty(window, 'isConfirmed', {
            get: () => sessionManager.get('isConfirmed'),
            set: (value) => sessionManager.set('isConfirmed', value)
        });
        Object.defineProperty(window, 'currentSessionState', {
            get: () => sessionManager.state,
            set: (value) => {
                console.warn('[DEPRECATED] Direct state assignment. Use sessionManager.transitionTo()');
                sessionManager.state = value;
            }
        });

        function addFirebaseListener(ref, eventType, callback) {
            return firebaseManager.addListener(ref, eventType, callback);
        }

        function cleanupFirebaseListeners() {
            firebaseManager.removeAllListeners();
        }

        function cleanupAllListeners() {
            if (currentCardCleanup) {
                currentCardCleanup();
                currentCardCleanup = null;
            }
            firebaseManager.removeAllListeners();
        }

        // Health monitoring - called periodically
        setInterval(() => {
            const fbHealth = firebaseManager.getHealthStatus();
            if (fbHealth.activeListeners > 10) {
                console.warn('[Health Check] Too many Firebase listeners:', fbHealth);
                sessionManager.logHealthCheck();
            }
        }, 30000); // Check every 30 seconds

        // Helper function for fetch with retry and error handling
        async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);

                    if (!response.ok) {
                        if (response.status === 429) {
                            // Rate limiting - wait longer
                            console.warn(`Rate limited (429). Retry ${i + 1}/${retries}`);
                            await new Promise(resolve => setTimeout(resolve, delay * (i + 2)));
                            continue;
                        } else if (response.status >= 500) {
                            // Server error - retry
                            console.warn(`Server error (${response.status}). Retry ${i + 1}/${retries}`);
                            await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
                            continue;
                        } else if (response.status === 401) {
                            // Unauthorized - API key issue
                            throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á TMDB');
                        } else {
                            // Other HTTP error
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    }

                    return response;
                } catch (error) {
                    if (i === retries - 1) {
                        // Last attempt failed
                        throw error;
                    }
                    console.warn(`Fetch error: ${error.message}. Retry ${i + 1}/${retries}`);
                    await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
                }
            }
        }

        // Initialize UI
        function initializeUI() {
            // Setup genres
            const genreGrid = document.getElementById('genreGrid');
            genres.forEach(genre => {
                const btn = document.createElement('button');
                btn.className = 'genre-btn';
                btn.textContent = genre.name;
                btn.onclick = () => toggleGenre(genre.id, btn);
                genreGrid.appendChild(btn);
            });

            // Setup countries
            const countryGrid = document.getElementById('countryGrid');
            countries.forEach(country => {
                const btn = document.createElement('button');
                btn.className = 'genre-btn';
                btn.textContent = country.name;
                btn.onclick = () => toggleCountry(country.code, btn);
                countryGrid.appendChild(btn);
            });

            // Setup movie count slider
            const slider = document.getElementById('movieCountSlider');
            const valueDisplay = document.getElementById('movieCountValue');
            slider.oninput = () => {
                movieCount = parseInt(slider.value);
                valueDisplay.textContent = movieCount;
            };

            // Setup year slider
            const yearSlider = document.getElementById('yearSlider');
            const yearValue = document.getElementById('yearValue');
            yearSlider.oninput = () => {
                minYear = parseInt(yearSlider.value);
                yearValue.textContent = minYear;
            };
        }

        function toggleGenre(genreId, btn) {
            const index = selectedGenres.indexOf(genreId);
            if (index > -1) {
                selectedGenres.splice(index, 1);
                btn.classList.remove('selected');
            } else {
                selectedGenres.push(genreId);
                btn.classList.add('selected');
            }
        }

        function toggleCountry(countryCode, btn) {
            const index = selectedCountries.indexOf(countryCode);
            if (index > -1) {
                selectedCountries.splice(index, 1);
                btn.classList.remove('selected');
            } else {
                selectedCountries.push(countryCode);
                btn.classList.add('selected');
            }
        }

        async function createSession() {
            if (selectedGenres.length === 0) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∂–∞–Ω—Ä!');
                return;
            }

            // Clean up any previous session data
            console.log('Creating new session - cleaning up old data...');
            firebaseManager.removeAllListeners();
            sessionManager.reset();

            sessionId = generateSessionId();
            isHost = true;

            // Update URL with session parameter so host can refresh page
            const newUrl = `${window.location.pathname}?session=${sessionId}`;
            window.history.replaceState({ sessionId: sessionId }, '', newUrl);
            console.log('Updated host URL with session:', newUrl);

            // Create session in Firebase first
            if (database) {
                // Show link screen immediately
                showScreen('linkScreen');
                document.querySelector('.session-info h2').textContent = '–°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏...';
                const link = `${window.location.origin}${window.location.pathname}?session=${sessionId}`;
                document.getElementById('sessionLink').textContent = link;
                document.querySelector('.session-link').style.display = 'block';
                document.querySelector('.waiting-message p').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–ª—å–º–æ–≤...';

                // Update session code display
                updateSessionCodeDisplay();

                try {
                    const success = await firebaseManager.write(`sessions/${sessionId}`, {
                        genres: selectedGenres,
                        countries: selectedCountries,
                        movieCount: movieCount,
                        minYear: minYear,
                        host: true,
                        partner: false,
                        hostChoices: {},
                        partnerChoices: {},
                        created: Date.now()
                    });

                    if (!success) {
                        throw new Error('Failed to write session to Firebase');
                    }
                    console.log('Session created in Firebase:', sessionId);
                } catch (error) {
                    console.error('Error creating session in Firebase:', error);
                    alert('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Å—Å–∏–∏: ' + error.message);
                    showScreen('setupScreen');
                    return;
                }

                // Check if partner already joined (in case they joined while we were creating session)
                const checkPartner = async () => {
                    try {
                        const partnerJoined = await firebaseManager.read(`sessions/${sessionId}/partner`);
                        console.log('Initial partner check:', partnerJoined);

                        if (partnerJoined === true) {
                            console.log('Partner already joined, starting swipe phase immediately');
                            startSwipePhase();
                            return true;
                        }
                        return false;
                    } catch (error) {
                        console.error('Error checking partner status:', error);
                        return false;
                    }
                };

                // Check first, then set up listener if needed
                const alreadyJoined = await checkPartner();
                if (!alreadyJoined) {
                    console.log('Partner not joined yet, setting up listener...');
                    // Listen for partner joining
                    let partnerJoinedFlag = false;
                    const partnerRef = database.ref(`sessions/${sessionId}/partner`);
                    const partnerJoinCallback = (snapshot) => {
                        const value = snapshot.val();
                        console.log('Partner listener triggered, value:', value);
                        if (value === true && !partnerJoinedFlag) {
                            partnerJoinedFlag = true;
                            console.log('Partner joined, starting swipe phase');
                            // Cleanup this specific listener since partner joined
                            const listenerId = sessionManager.get('partnerJoinListenerId');
                            if (listenerId) {
                                firebaseManager.removeListener(listenerId);
                                sessionManager.set('partnerJoinListenerId', null);
                            }
                            startSwipePhase();
                        }
                    };
                    const listenerId = firebaseManager.addListener(partnerRef, 'value', partnerJoinCallback);
                    sessionManager.set('partnerJoinListenerId', listenerId);
                }
            } else {
                // Demo mode - show loading
                showScreen('linkScreen');
                document.querySelector('.session-info h2').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–ª—å–º–æ–≤...';
                document.querySelector('.session-link').style.display = 'none';
                document.querySelector('.waiting-message p').textContent = '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...';
            }

            // Fetch movies in background
            try {
                console.log('Host: Starting to fetch movies...');
                await fetchMovies();
                console.log('Host: Movies fetched successfully, count:', movies.length);

                if (movies.length === 0) {
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∏–ª—å–º—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–∏–µ –∂–∞–Ω—Ä—ã –∏–ª–∏ —Å—Ç—Ä–∞–Ω—ã.');
                    showScreen('setupScreen');
                    return;
                }

                // Save movies to Firebase so partner can read them
                if (database) {
                    console.log('Host: Saving movies to Firebase...');
                    console.log('Host: Movies to save:', movies.length, 'movies');
                    console.log('Host: First 3 movie IDs:', movies.slice(0, 3).map(m => m.id));
                    console.log('Host: First movie title:', movies[0] ? movies[0].title : 'N/A');
                    try {
                        await firebaseManager.update(`sessions/${sessionId}`, {
                            movies: movies,
                            moviesReady: true
                        });
                        console.log('Host: Movies saved to Firebase successfully');
                    } catch (error) {
                        console.error('Host: Error saving movies to Firebase:', error);
                    }
                }

                // Update status after movies loaded
                if (database) {
                    document.querySelector('.session-info h2').textContent = '–°–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞!';
                    document.querySelector('.waiting-message p').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤—Ç–æ—Ä–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞...';

                    // Check again if partner joined while we were fetching movies
                    console.log('Host: Checking if partner joined while fetching movies...');
                    try {
                        const partnerJoined = await firebaseManager.read(`sessions/${sessionId}/partner`);
                        if (partnerJoined === true) {
                            console.log('Host: Partner already joined! Starting swipe phase now.');
                            startSwipePhase();
                        } else {
                            console.log('Host: Partner not joined yet, waiting...');
                        }
                    } catch (error) {
                        console.error('Host: Error checking partner status after fetch:', error);
                    }
                } else {
                    // Demo mode - start immediately
                    startSwipePhase();
                }
            } catch (error) {
                console.error('Error in createSession:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∏–ª—å–º–æ–≤: ' + error.message);
                showScreen('setupScreen');
                return;
            }
        }

        async function joinSession(sessionId) {
            // Clean up any previous session data
            console.log('Joining session - cleaning up old data...');
            firebaseManager.removeAllListeners();
            sessionManager.reset();

            // Show loading
            showScreen('linkScreen');
            document.querySelector('.session-info h2').textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Å—Å–∏–∏...';
            document.querySelector('.session-link').style.display = 'none';

            if (database) {
                try {
                    console.log('Attempting to join session:', sessionId);
                    const sessionData = await firebaseManager.read(`sessions/${sessionId}`);

                    console.log('Session data exists:', sessionData !== null);

                    if (!sessionData) {
                        console.error('Session not found:', sessionId);
                        alert('–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞! –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω–∞ –µ—â—ë –Ω–µ —Å–æ–∑–¥–∞–Ω–∞ –∏–ª–∏ –∏—Å—Ç–µ–∫–ª–∞.');
                        window.location.href = window.location.pathname; // Redirect to home
                        return;
                    }

                    console.log('Session data:', sessionData);

                    // Validate session data
                    try {
                        validateSessionData(sessionData);
                    } catch (validationError) {
                        console.error('Session validation failed:', validationError);
                        alert('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏: ' + validationError.message);
                        window.location.href = window.location.pathname;
                        return;
                    }

                    selectedGenres = sessionData.genres;
                    selectedCountries = sessionData.countries || [];
                    movieCount = sessionData.movieCount;
                    minYear = sessionData.minYear || 2000;
                    isHost = false;

                    // Mark partner as joined (use update to avoid overwriting host data)
                    console.log('Setting partner: true in Firebase...');
                    const success = await firebaseManager.update(`sessions/${sessionId}`, { partner: true });
                    if (!success) {
                        throw new Error('Failed to mark partner as joined');
                    }
                    console.log('Successfully set partner: true');

                    // Verify the update
                    const verifyData = await firebaseManager.read(`sessions/${sessionId}`);
                    console.log('Verified session data after update:', verifyData);

                    // Listen for host choices
                    const hostChoicesRef = database.ref(`sessions/${sessionId}/hostChoices`);
                    const hostChoicesListenerId = firebaseManager.addListener(
                        hostChoicesRef,
                        'value',
                        (snapshot) => {
                            partnerChoices = snapshot.val() || {};
                        }
                    );
                    sessionManager.set('hostChoicesListenerId', hostChoicesListenerId);

                    // Wait for host to load movies and read from Firebase
                    console.log('Partner: Waiting for host to load movies...');
                    document.querySelector('.session-info h2').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∏–ª—å–º–æ–≤...';
                    document.querySelector('.waiting-message p').textContent = '–•–æ—Å—Ç –∑–∞–≥—Ä—É–∂–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ñ–∏–ª—å–º–æ–≤...';

                    // Check if movies already loaded
                    if (sessionData.moviesReady && sessionData.movies) {
                        console.log('Partner: Movies already loaded by host, using them');
                        console.log('Partner: sessionData.movies length:', sessionData.movies.length);
                        console.log('Partner: sessionData.movies type:', typeof sessionData.movies, Array.isArray(sessionData.movies));
                        movies = sessionData.movies;
                        console.log('Partner: Loaded', movies.length, 'movies from Firebase');
                        console.log('Partner: First 3 movie IDs:', movies.slice(0, 3).map(m => m.id));
                        console.log('Partner: First movie title:', movies[0] ? movies[0].title : 'N/A');
                        startSwipePhase();
                    } else {
                        // Movies not ready yet, wait for them
                        console.log('Partner: Movies not ready, setting up listener...');
                        const moviesRef = database.ref(`sessions/${sessionId}/moviesReady`);
                        let moviesLoaded = false;

                        const moviesReadyCallback = async (snapshot) => {
                            const ready = snapshot.val();
                            if (ready === true && !moviesLoaded) {
                                moviesLoaded = true;
                                console.log('Partner: Movies ready, loading...');

                                // Remove listener
                                const listenerId = sessionManager.get('moviesReadyListenerId');
                                if (listenerId) {
                                    firebaseManager.removeListener(listenerId);
                                    sessionManager.set('moviesReadyListenerId', null);
                                }

                                // Read movies from Firebase
                                const moviesData = await firebaseManager.read(`sessions/${sessionId}/movies`);
                                if (moviesData) {
                                    console.log('Partner: moviesData length:', moviesData.length);
                                    console.log('Partner: moviesData type:', typeof moviesData, Array.isArray(moviesData));
                                    movies = moviesData;
                                    console.log('Partner: Loaded', movies.length, 'movies from Firebase (listener)');
                                    console.log('Partner: First 3 movie IDs:', movies.slice(0, 3).map(m => m.id));
                                    console.log('Partner: First movie title:', movies[0] ? movies[0].title : 'N/A');
                                    startSwipePhase();
                                } else {
                                    console.error('Partner: Failed to load movies from Firebase');
                                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ñ–∏–ª—å–º–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ.');
                                    window.location.href = window.location.pathname;
                                }
                            }
                        };

                        const listenerId = firebaseManager.addListener(moviesRef, 'value', moviesReadyCallback);
                        sessionManager.set('moviesReadyListenerId', listenerId);

                        // Timeout after 30 seconds
                        setTimeout(() => {
                            if (!moviesLoaded) {
                                const listenerId = sessionManager.get('moviesReadyListenerId');
                                if (listenerId) {
                                    firebaseManager.removeListener(listenerId);
                                    sessionManager.set('moviesReadyListenerId', null);
                                }
                                alert('–í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∏–ª—å–º–æ–≤ –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ.');
                                window.location.href = window.location.pathname;
                            }
                        }, 30000);
                    }
                } catch (error) {
                    console.error('Error joining session:', error);
                    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ —Å–µ—Å—Å–∏–∏: ' + error.message);
                    window.location.href = window.location.pathname;
                }
            } else {
                alert('Firebase –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ —Å–µ—Å—Å–∏–∏.');
                window.location.href = window.location.pathname;
            }
        }

        async function fetchMovies(retryCount = 0, maxRetries = 3) {
            console.log(`fetchMovies() attempt ${retryCount + 1}/${maxRetries + 1} with ${movieCount} movies requested`);

            // Update loading message with retry info
            if (document.querySelector('.waiting-message p')) {
                if (retryCount > 0) {
                    document.querySelector('.waiting-message p').textContent = `–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–ª—å–º–æ–≤... (–ø–æ–ø—ã—Ç–∫–∞ ${retryCount + 1}/${maxRetries + 1})`;
                } else {
                    document.querySelector('.waiting-message p').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–ª—å–º–æ–≤...';
                }
            }

            // Demo movies for testing without API
            const demoMovies = [
                {
                    id: 1,
                    title: '–ù–∞—á–∞–ª–æ',
                    overview: '–ö–æ–±–± ‚Äì —Ç–∞–ª–∞–Ω—Ç–ª–∏–≤—ã–π –≤–æ—Ä, –ª—É—á—à–∏–π –∏–∑ –ª—É—á—à–∏—Ö –≤ –æ–ø–∞—Å–Ω–æ–º –∏—Å–∫—É—Å—Å—Ç–≤–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è...',
                    poster: 'üé≠',
                    rating: '8.8',
                    year: '2010',
                    director: 'Christopher Nolan',
                    movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–¢—Ä–∏–ª–ª–µ—Ä'],
                    languages: ['rus', 'eng']
                },
                {
                    id: 2,
                    title: '–ò–Ω—Ç–µ—Ä—Å—Ç–µ–ª–ª–∞—Ä',
                    overview: '–ö–æ–≥–¥–∞ –∑–∞—Å—É—Ö–∞ –ø—Ä–∏–≤–æ–¥–∏—Ç —á–µ–ª–æ–≤–µ—á–µ—Å—Ç–≤–æ –∫ –ø—Ä–æ–¥–æ–≤–æ–ª—å—Å—Ç–≤–µ–Ω–Ω–æ–º—É –∫—Ä–∏–∑–∏—Å—É...',
                    poster: 'üöÄ',
                    rating: '8.6',
                    year: '2014',
                    director: 'Christopher Nolan',
                    movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–î—Ä–∞–º–∞'],
                    languages: ['rus', 'eng']
                },
                {
                    id: 3,
                    title: '–ú–∞—Ç—Ä–∏—Ü–∞',
                    overview: '–ñ–∏–∑–Ω—å –¢–æ–º–∞—Å–∞ –ê–Ω–¥–µ—Ä—Å–æ–Ω–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∞ –Ω–∞ –¥–≤–µ —á–∞—Å—Ç–∏...',
                    poster: 'üíä',
                    rating: '8.7',
                    year: '1999',
                    director: 'Lana Wachowski',
                    movieGenres: ['–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', '–ë–æ–µ–≤–∏–∫'],
                    languages: ['rus', 'eng']
                },
                {
                    id: 4,
                    title: '–¢–µ–º–Ω—ã–π —Ä—ã—Ü–∞—Ä—å',
                    overview: '–ë—ç—Ç–º–µ–Ω –ø–æ–¥–Ω–∏–º–∞–µ—Ç —Å—Ç–∞–≤–∫–∏ –≤ –≤–æ–π–Ω–µ —Å –∫—Ä–∏–º–∏–Ω–∞–ª–æ–º...',
                    poster: 'ü¶á',
                    rating: '9.0',
                    year: '2008',
                    director: 'Christopher Nolan',
                    movieGenres: ['–ë–æ–µ–≤–∏–∫', '–î—Ä–∞–º–∞'],
                    languages: ['rus', 'eng']
                },
                {
                    id: 5,
                    title: '–§–æ—Ä—Ä–µ—Å—Ç –ì–∞–º–ø',
                    overview: '–û—Ç –ª–∏—Ü–∞ –≥–ª–∞–≤–Ω–æ–≥–æ –≥–µ—Ä–æ—è –§–æ—Ä—Ä–µ—Å—Ç–∞ –ì–∞–º–ø–∞...',
                    poster: 'üèÉ',
                    rating: '8.8',
                    year: '1994',
                    director: 'Robert Zemeckis',
                    movieGenres: ['–î—Ä–∞–º–∞', '–ú–µ–ª–æ–¥—Ä–∞–º–∞'],
                    languages: ['rus', 'eng']
                }
            ];

            // If TMDB API key not configured, use demo movies
            if (TMDB_API_KEY === 'YOUR_TMDB_API_KEY') {
                console.log('TMDB API key not configured, using demo movies only');
                movies = [];
                for (let i = 0; i < movieCount; i++) {
                    movies.push(demoMovies[i % demoMovies.length]);
                }
                console.log('Demo movies loaded:', movies.length);
                return;
            }

            // Try to fetch real movies from TMDB
            console.log('TMDB API key found, fetching real movies...');
            try {
                const genreParam = selectedGenres.join(',');
                const countryParam = selectedCountries.length > 0 ? selectedCountries.join('|') : '';
                const pagesNeeded = Math.ceil(movieCount / 20);
                const allMovies = [];

                // Randomize sorting method for variety
                const sortOptions = [
                    'popularity.desc',
                    'vote_average.desc',
                    'vote_count.desc',
                    'primary_release_date.desc'
                ];
                const randomSort = sortOptions[Math.floor(Math.random() * sortOptions.length)];
                console.log('Using random sort:', randomSort);

                // Start from a random page (1-10) for more variety
                const startPage = Math.floor(Math.random() * 10) + 1;
                console.log('Starting from random page:', startPage);

                // Fetch multiple pages if needed
                for (let i = 0; i < Math.min(pagesNeeded, 10); i++) {
                    const page = startPage + i;
                    let url = `${TMDB_BASE_URL}/discover/movie?api_key=${TMDB_API_KEY}&with_genres=${genreParam}&language=ru-RU&sort_by=${randomSort}&page=${page}&include_adult=false&vote_average.gte=5&primary_release_date.gte=${minYear}-01-01`;

                    // Add country filter if selected
                    if (countryParam) {
                        url += `&with_origin_country=${countryParam}`;
                    }

                    console.log(`Fetching page ${page}...`);
                    const response = await fetchWithRetry(url);
                    const data = await response.json();
                    console.log(`Page ${page} returned ${data.results && data.results.length ? data.results.length : 0} movies`);

                    // Filter movies with rating >= 5 and year >= minYear
                    const filteredResults = data.results.filter(movie => {
                        const year = movie.release_date ? parseInt(movie.release_date.split('-')[0]) : 0;
                        return movie.vote_average >= 5 && year >= minYear;
                    });
                    console.log(`After filtering: ${filteredResults.length} movies`);
                    allMovies.push(...filteredResults);

                    if (allMovies.length >= movieCount * 1.5) break; // Get extra to account for filtering
                }
                console.log(`Total movies fetched: ${allMovies.length}`);

                // ‚úÖ OPTIMIZATION: Use data directly from /discover without additional requests
                // Previously: 20-30 detailed API calls (~60-90 seconds)
                // Now: 0 additional calls (~0 seconds)
                console.log(`Processing movie data without additional API calls...`);

                const filteredMovies = allMovies.slice(0, movieCount * 1.5).map(movie => {
                    try {
                        // Convert genre_ids to genre names using local genres array
                        const movieGenres = (movie.genre_ids || [])
                            .map(id => {
                                const genre = genres.find(g => g.id === id);
                                return genre ? genre.name : null;
                            })
                            .filter(name => name !== null);

                        // Determine languages based on original_language
                        // Most movies with Russian translation will have original_language metadata
                        const availableLanguages = [];
                        if (movie.original_language === 'ru') {
                            availableLanguages.push('rus');
                        }
                        // Since we're using language=ru-RU in query, we get Russian-friendly content
                        // Add both for broader compatibility (can refine based on popularity in region)
                        if (movie.original_language === 'en' || movie.vote_count > 100) {
                            availableLanguages.push('eng');
                        }
                        // Default fallback if no languages detected
                        if (availableLanguages.length === 0) {
                            availableLanguages.push('rus', 'eng');
                        }

                        return {
                            id: movie.id,
                            title: movie.title,
                            overview: movie.overview || '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç',
                            poster: movie.poster_path ? `${TMDB_IMAGE_BASE}${movie.poster_path}` : 'üé¨',
                            rating: movie.vote_average ? movie.vote_average.toFixed(1) : 'N/A',
                            year: movie.release_date ? movie.release_date.split('-')[0] : 'N/A',
                            director: 'TMDB', // No director data without detailed request (acceptable tradeoff)
                            movieGenres: movieGenres,
                            languages: availableLanguages
                        };
                    } catch (err) {
                        console.warn('Error processing movie:', movie.title, err);
                        return null;
                    }
                }).filter(movie => movie !== null);

                console.log(`Loaded ${filteredMovies.length} movies after language filtering`);

                if (filteredMovies.length === 0) {
                    // No movies found - retry if we haven't exceeded max retries
                    if (retryCount < maxRetries) {
                        console.warn(`No movies found. Retrying... (${retryCount + 1}/${maxRetries})`);
                        showToast(`–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–ª—å–º–æ–≤ –Ω–µ —É–¥–∞–ª–∞—Å—å. –ü–æ–≤—Ç–æ—Ä ${retryCount + 2}/${maxRetries + 1}...`, 'error', 3000);
                        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retry
                        return await fetchMovies(retryCount + 1, maxRetries);
                    } else {
                        console.error('Max retries exceeded. Using demo movies.');
                        showToast('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∏–ª—å–º—ã –∏–∑ TMDB –ø–æ—Å–ª–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–æ–ø—ã—Ç–æ–∫.', 'error', 5000);
                        // Load demo movies as last resort
                        movies = [];
                        for (let i = 0; i < movieCount; i++) {
                            movies.push(demoMovies[i % demoMovies.length]);
                        }
                    }
                } else {
                    // Shuffle the array for randomness
                    const shuffled = filteredMovies.sort(() => Math.random() - 0.5);
                    movies = shuffled.slice(0, movieCount);
                    console.log(`Successfully loaded ${movies.length} real movies from TMDB (shuffled)`);
                }
            } catch (error) {
                console.error('Error fetching movies:', error);

                // Retry if we haven't exceeded max retries
                if (retryCount < maxRetries) {
                    console.log(`Retrying after error... (${retryCount + 1}/${maxRetries})`);
                    showToast(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${error.message}. –ü–æ–≤—Ç–æ—Ä ${retryCount + 2}/${maxRetries + 1}...`, 'error', 3000);
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retry
                    return await fetchMovies(retryCount + 1, maxRetries);
                } else {
                    console.error('Max retries exceeded after errors. Using demo movies.');
                    showToast('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∏–ª—å–º—ã –ø–æ—Å–ª–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–æ–ø—ã—Ç–æ–∫.', 'error', 5000);
                    // Load demo movies as last resort
                    movies = [];
                    for (let i = 0; i < movieCount; i++) {
                        movies.push(demoMovies[i % demoMovies.length]);
                    }
                }
            }

            console.log('fetchMovies() completed. Total movies:', movies.length);
        }

        function startSwipePhase() {
            console.log('Starting swipe phase, state:', SessionState.SWIPING);
            console.log('startSwipePhase: movies count:', movies.length);
            console.log('startSwipePhase: First 3 movie IDs:', movies.slice(0, 3).map(m => m.id));
            console.log('startSwipePhase: isHost:', isHost);

            const transitioned = sessionManager.transitionTo(SessionState.SWIPING);
            if (!transitioned) {
                console.error('Failed to transition to SWIPING');
                return;
            }
            showScreen('swipeScreen');

            // Display session code if available
            if (sessionId) {
                document.getElementById('sessionCodeDisplay').style.display = 'block';
                document.getElementById('sessionCodeText').textContent = sessionId;
            }

            // Display selected genres
            const genreTags = document.getElementById('genreTags');
            genreTags.innerHTML = selectedGenres.map(genreId => {
                const genre = genres.find(g => g.id === genreId);
                return `<span class="genre-tag">${genre ? genre.name : ''}</span>`;
            }).join('');

            // Listen for partner completion if in Firebase mode
            // This listener will be cleaned up when we enter WAITING_FOR_MATCHES state
            if (database && sessionId) {
                const partnerChoicesKey = isHost ? 'partnerChoices' : 'hostChoices';
                const partnerChoicesRef = database.ref(`sessions/${sessionId}/${partnerChoicesKey}`);
                const listenerId = firebaseManager.addListener(
                    partnerChoicesRef,
                    'value',
                    (snapshot) => {
                        const choices = snapshot.val() || {};
                        // Only show partner status if we're still in SWIPING state
                        if (currentSessionState === SessionState.SWIPING &&
                            Object.keys(choices).length >= movies.length &&
                            currentMovieIndex < movies.length) {
                            document.getElementById('partnerStatus').classList.add('show');
                        }
                    }
                );
                sessionManager.set('partnerChoicesSwipeListenerId', listenerId);
            }

            renderCurrentCard();
        }

        function renderCurrentCard() {
            const cardStack = document.getElementById('cardStack');
            cardStack.innerHTML = '<div class="swipe-indicator left" id="dislikeIndicator">‚úó</div><div class="swipe-indicator right" id="likeIndicator">‚ô•</div>';

            if (currentMovieIndex >= movies.length) {
                checkMatches();
                return;
            }

            const movie = movies[currentMovieIndex];
            const card = document.createElement('div');
            card.className = 'movie-card';
            card.id = 'currentCard';

            // Language badges
            const languageBadges = movie.languages && movie.languages.length > 0
                ? `<div class="language-badges">
                    ${movie.languages.map(lang => `<span class="language-badge ${lang}">${lang}</span>`).join('')}
                   </div>`
                : '';

            const posterContent = movie.poster.startsWith('http')
                ? `<div class="movie-poster">
                    <img src="${escapeHtml(movie.poster)}" alt="${escapeHtml(movie.title)}">
                    ${languageBadges}
                    ${movie.rating !== 'N/A' ? `<div class="movie-rating">‚≠ê ${escapeHtml(movie.rating)}</div>` : ''}
                   </div>`
                : `<div class="movie-poster">${movie.poster}</div>`;

            const genresHtml = movie.movieGenres && movie.movieGenres.length > 0
                ? `<div class="movie-genres">${movie.movieGenres.slice(0, 3).map(g => `<span class="movie-genre">${escapeHtml(g)}</span>`).join('')}</div>`
                : '';

            const metaHtml = `
                <div class="movie-meta">
                    ${movie.year !== 'N/A' ? `<span>üìÖ ${escapeHtml(movie.year)}</span>` : ''}
                    ${movie.director !== '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω' ? `<span>üé¨ ${escapeHtml(movie.director)}</span>` : ''}
                </div>
            `;

            card.innerHTML = `
                ${posterContent}
                <div class="movie-info">
                    <div class="movie-title">${escapeHtml(movie.title)}</div>
                    ${metaHtml}
                    ${genresHtml}
                    <div class="movie-description">${escapeHtml(movie.overview)}</div>
                </div>
            `;

            cardStack.appendChild(card);
            setupSwipeHandlers(card);
            updateProgress();
            updateCounter();
        }

        function setupSwipeHandlers(card) {
            // Cleanup previous card's listeners
            if (currentCardCleanup) {
                currentCardCleanup();
            }

            let startX = 0;
            let currentX = 0;
            let isDragging = false;

            const dislikeIndicator = document.getElementById('dislikeIndicator');
            const likeIndicator = document.getElementById('likeIndicator');

            function startDrag(e) {
                isDragging = true;
                startX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
                card.classList.add('swiping');
            }

            function drag(e) {
                if (!isDragging) return;
                currentX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                const diff = currentX - startX;
                card.style.transform = `translateX(${diff}px) rotate(${diff * 0.1}deg)`;

                if (diff < -50) {
                    dislikeIndicator.classList.add('visible');
                    likeIndicator.classList.remove('visible');
                } else if (diff > 50) {
                    likeIndicator.classList.add('visible');
                    dislikeIndicator.classList.remove('visible');
                } else {
                    dislikeIndicator.classList.remove('visible');
                    likeIndicator.classList.remove('visible');
                }
            }

            function endDrag() {
                if (!isDragging) return;
                isDragging = false;
                card.classList.remove('swiping');

                const diff = currentX - startX;
                if (Math.abs(diff) > 100) {
                    swipe(diff > 0 ? 'like' : 'dislike');
                } else {
                    card.style.transform = '';
                    dislikeIndicator.classList.remove('visible');
                    likeIndicator.classList.remove('visible');
                }
            }

            // Attach listeners to card
            card.addEventListener('mousedown', startDrag);
            card.addEventListener('touchstart', startDrag);

            // Attach listeners to document
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);

            // Store cleanup function
            currentCardCleanup = function() {
                card.removeEventListener('mousedown', startDrag);
                card.removeEventListener('touchstart', startDrag);
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchend', endDrag);
            };
        }

        async function swipe(choice) {
            const movie = movies[currentMovieIndex];
            userChoices[movie.id] = choice === 'like';

            // Save to Firebase and wait for completion
            const savePromise = (database && sessionId)
                ? (async () => {
                    const choicesKey = isHost ? 'hostChoices' : 'partnerChoices';
                    await firebaseManager.write(`sessions/${sessionId}/${choicesKey}/${movie.id}`, choice === 'like');
                  })()
                : Promise.resolve();

            const card = document.getElementById('currentCard');
            if (card) {
                const direction = choice === 'like' ? 1 : -1;
                card.style.transform = `translateX(${direction * 1000}px) rotate(${direction * 50}deg)`;
                setTimeout(() => {
                    // Wait for Firebase write to complete before proceeding
                    savePromise.then(() => {
                        currentMovieIndex++;
                        renderCurrentCard();
                    });
                }, 300);
            } else {
                // Wait for Firebase write to complete before proceeding
                savePromise.then(() => {
                    currentMovieIndex++;
                    renderCurrentCard();
                });
            }
        }

        function updateProgress() {
            const progress = (currentMovieIndex / movies.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        function updateCounter() {
            const remaining = movies.length - currentMovieIndex;
            document.getElementById('moviesRemaining').textContent = remaining;
        }

        async function checkMatches() {
            // Guard: prevent re-entry if we already moved past SWIPING
            if (currentSessionState !== SessionState.SWIPING) {
                console.log('checkMatches() called but already in state:', currentSessionState, '- ignoring');
                return;
            }

            console.log('checkMatches() - transitioning to WAITING_FOR_MATCHES');
            const transitioned = sessionManager.transitionTo(SessionState.WAITING_FOR_MATCHES);
            if (!transitioned) {
                console.error('Failed to transition to WAITING_FOR_MATCHES');
                return;
            }

            // Clean up all listeners from swipe phase
            cleanupAllListeners();

            // Mark ourselves as finished in Firebase
            if (database && sessionId) {
                const finishedKey = isHost ? 'hostFinished' : 'partnerFinished';
                await firebaseManager.write(`sessions/${sessionId}/${finishedKey}`, true);
                console.log('Marked as finished in Firebase');
            }

            // Wait for partner to finish if needed
            if (database && sessionId) {
                showScreen('linkScreen');
                document.querySelector('.session-info h2').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –ø–∞—Ä—Ç–Ω–µ—Ä–∞...';

                const partnerChoicesKey = isHost ? 'partnerChoices' : 'hostChoices';
                const partnerFinishedKey = isHost ? 'partnerFinished' : 'hostFinished';

                // First, check current state (partner might have already finished)
                try {
                    const [choices, finished] = await Promise.all([
                        firebaseManager.read(`sessions/${sessionId}/${partnerChoicesKey}`),
                        firebaseManager.read(`sessions/${sessionId}/${partnerFinishedKey}`)
                    ]);

                    partnerChoices = choices || {};
                    const partnerFinished = finished;

                    // If partner already finished, show matches immediately
                    if (partnerFinished === true || Object.keys(partnerChoices).length >= movies.length) {
                        console.log('Partner already finished, showing matches');
                        showMatches();
                        return;
                    }
                } catch (error) {
                    console.error('Error checking partner status:', error);
                }

                // Partner hasn't finished yet, set up listener for finished flag
                let matchesShown = false;
                const partnerFinishedRef = database.ref(`sessions/${sessionId}/${partnerFinishedKey}`);
                const checkPartnerFinishedCallback = (snapshot) => {
                    const partnerFinished = snapshot.val();
                    if (partnerFinished === true && !matchesShown) {
                        matchesShown = true;
                        const listenerId = sessionManager.get('partnerFinishedListenerId');
                        if (listenerId) {
                            firebaseManager.removeListener(listenerId);
                            sessionManager.set('partnerFinishedListenerId', null);
                        }
                        console.log('Partner finished flag detected, loading choices and showing matches');
                        // Load partner choices and show matches
                        firebaseManager.read(`sessions/${sessionId}/${partnerChoicesKey}`).then(choices => {
                            partnerChoices = choices || {};
                            showMatches();
                        });
                    }
                };

                const listenerId = firebaseManager.addListener(partnerFinishedRef, 'value', checkPartnerFinishedCallback);
                sessionManager.set('partnerFinishedListenerId', listenerId);

                // Add timeout after 5 minutes
                setTimeout(() => {
                    if (!matchesShown) {
                        matchesShown = true;
                        const listenerId = sessionManager.get('partnerFinishedListenerId');
                        if (listenerId) {
                            firebaseManager.removeListener(listenerId);
                            sessionManager.set('partnerFinishedListenerId', null);
                        }
                        alert('–í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –ø–∞—Ä—Ç–Ω–µ—Ä–∞ –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é.');
                        startOver();
                    }
                }, 5 * 60 * 1000); // 5 minutes
            } else {
                // Demo mode - simulate partner choices (randomly like 40-60% of movies)
                movies.forEach(movie => {
                    partnerChoices[movie.id] = Math.random() > 0.5;
                });
                setTimeout(() => showMatches(), 500);
            }
        }

        function showMatches() {
            console.log('showMatches() - transitioning to SELECTING');

            // Guard: ensure movies are loaded
            if (!movies || movies.length === 0) {
                console.error('showMatches() called but movies not loaded yet!');
                console.error('Current state:', {
                    movies: movies,
                    moviesLength: movies ? movies.length : 0,
                    userChoices: Object.keys(userChoices).length,
                    partnerChoices: Object.keys(partnerChoices).length
                });
                return; // Don't show error, just return - movies might still be loading
            }

            const transitioned = sessionManager.transitionTo(SessionState.SELECTING);
            if (!transitioned) {
                console.error('Failed to transition to SELECTING');
                return;
            }

            const matches = movies.filter(movie =>
                userChoices[movie.id] === true && partnerChoices[movie.id] === true
            );

            if (matches.length === 0) {
                alert('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑!');
                startOver();
                return;
            }

            if (matches.length === 1) {
                showFinalChoice(matches[0]);
                return;
            }

            // Save matched movies for later reference
            matchedMovies = matches;

            // Set up real-time listener for partner's selection
            if (database && sessionId) {
                const partnerSelectionKey = isHost ? 'partnerCurrentSelection' : 'hostCurrentSelection';
                const partnerSelectionRef = database.ref(`sessions/${sessionId}/${partnerSelectionKey}`);

                const listenerId = firebaseManager.addListener(partnerSelectionRef, 'value', (snapshot) => {
                    const newPartnerSelection = snapshot.val();
                    console.log('Partner selection changed:', newPartnerSelection);
                    partnerSelectedMovieId = newPartnerSelection;
                    renderMatchesGrid(); // Re-render to show partner's choice
                });
                sessionManager.set('partnerSelectionListenerId', listenerId);
            }

            showScreen('resultsScreen');
            renderMatchesGrid();
        }

        function renderMatchesGrid() {
            const matchesGrid = document.getElementById('matchesGrid');
            const bothSelectedSame = selectedMovieId && selectedMovieId === partnerSelectedMovieId;

            matchesGrid.innerHTML = matchedMovies.map(movie => {
                const posterContent = movie.poster.startsWith('http')
                    ? `<img src="${escapeHtml(movie.poster)}" class="match-poster" alt="${escapeHtml(movie.title)}">`
                    : `<div class="match-poster" style="display: flex; align-items: center; justify-content: center; font-size: 40px;">${movie.poster}</div>`;

                const isSelectedByYou = selectedMovieId === movie.id;
                const isSelectedByPartner = partnerSelectedMovieId === movie.id;

                let cardClass = 'match-card';
                if (isSelectedByYou) cardClass += ' selected-by-you';

                return `
                    <div class="${cardClass}" onclick="toggleMovieSelection(${movie.id})">
                        ${posterContent}
                        <div class="match-info">
                            <div class="match-title">${escapeHtml(movie.title)}</div>
                            <div class="match-description">${escapeHtml(movie.overview)}</div>
                            <div class="selection-indicators">
                                ${isSelectedByYou ? '<span class="selection-badge you">‚úì –í–∞—à –≤—ã–±–æ—Ä</span>' : ''}
                                ${isSelectedByPartner ? '<span class="selection-badge partner">‚úì –í—ã–±–æ—Ä –ø–∞—Ä—Ç–Ω–µ—Ä–∞</span>' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Determine message and button state
            let message = '';
            let buttonDisabled = true;

            if (!selectedMovieId) {
                message = '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫—É —Ñ–∏–ª—å–º–∞, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –µ–≥–æ.';
            } else if (!partnerSelectedMovieId) {
                message = '–ñ–¥—ë–º –ø–æ–∫–∞ –ø–∞—Ä—Ç–Ω–µ—Ä –≤—ã–±–µ—Ä–µ—Ç —Ñ–∏–ª—å–º...';
            } else if (bothSelectedSame) {
                message = '‚úì –û–±–∞ –≤—ã–±—Ä–∞–ª–∏ –æ–¥–∏–Ω —Ñ–∏–ª—å–º! –ú–æ–∂–µ—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä.';
                buttonDisabled = false;
            } else {
                message = '‚ö†Ô∏è –í—ã –≤—ã–±—Ä–∞–ª–∏ —Ä–∞–∑–Ω—ã–µ —Ñ–∏–ª—å–º—ã. –ò–∑–º–µ–Ω–∏—Ç–µ –≤—ã–±–æ—Ä, —á—Ç–æ–±—ã —Å–æ–≤–ø–∞–ª —Å –ø–∞—Ä—Ç–Ω–µ—Ä–æ–º.';
            }

            // Add confirmation button
            matchesGrid.innerHTML += `
                <div class="confirm-selection-container">
                    <div class="confirm-selection-info">
                        ${message}
                    </div>
                    <button class="btn" id="confirmBtn" onclick="confirmSelection()" ${buttonDisabled ? 'disabled' : ''}>
                        –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä
                    </button>
                </div>
            `;
        }

        function toggleMovieSelection(movieId) {
            if (isConfirmed) return; // Already confirmed, can't change

            // Toggle selection
            selectedMovieId = selectedMovieId === movieId ? null : movieId;

            // Immediately send selection to Firebase (real-time update)
            if (database && sessionId) {
                const selectionKey = isHost ? 'hostCurrentSelection' : 'partnerCurrentSelection';
                firebaseManager.write(`sessions/${sessionId}/${selectionKey}`, selectedMovieId)
                    .then((success) => {
                        if (success) {
                            console.log('Selection updated in Firebase:', selectedMovieId);
                        } else {
                            console.error('Error updating selection');
                        }
                    });
            }

            renderMatchesGrid();
        }

        function confirmSelection() {
            if (!selectedMovieId || isConfirmed) return;

            // Check that both selected the same movie
            if (selectedMovieId !== partnerSelectedMovieId) {
                alert('–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ä–∞–∑–Ω—ã–µ —Ñ–∏–ª—å–º—ã! –ò–∑–º–µ–Ω–∏—Ç–µ –≤—ã–±–æ—Ä, —á—Ç–æ–±—ã —Å–æ–≤–ø–∞–ª —Å –ø–∞—Ä—Ç–Ω–µ—Ä–æ–º.');
                return;
            }

            isConfirmed = true;

            // Update UI to show confirmation
            document.getElementById('confirmBtn').disabled = true;
            document.getElementById('confirmBtn').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–∞—Ä—Ç–Ω–µ—Ä–∞...';

            // Send confirmation to Firebase and wait for partner
            waitForPartnerConfirmation();
        }

        async function waitForPartnerConfirmation() {
            // Guard: prevent re-entry if we already moved past SELECTING
            if (currentSessionState !== SessionState.SELECTING) {
                console.log('waitForPartnerConfirmation() called but already in state:', currentSessionState, '- ignoring');
                return;
            }

            console.log('waitForPartnerConfirmation() - transitioning to WAITING_FOR_SELECTION');
            const transitioned = sessionManager.transitionTo(SessionState.WAITING_FOR_SELECTION);
            if (!transitioned) {
                console.error('Failed to transition to WAITING_FOR_SELECTION');
                return;
            }

            const movie = matchedMovies.find(m => m.id === selectedMovieId);
            if (!movie) {
                console.error('Selected movie not found!');
                return;
            }

            // Send confirmation to Firebase
            if (database && sessionId) {
                const confirmationKey = isHost ? 'hostConfirmed' : 'partnerConfirmed';
                await firebaseManager.write(`sessions/${sessionId}/${confirmationKey}`, true);
                console.log('Sent confirmation to Firebase');

                // Check if partner already confirmed
                const partnerConfirmationKey = isHost ? 'partnerConfirmed' : 'hostConfirmed';

                try {
                    const partnerConfirmed = await firebaseManager.read(`sessions/${sessionId}/${partnerConfirmationKey}`);

                    // If partner already confirmed, show final movie immediately
                    if (partnerConfirmed === true) {
                        console.log('Partner already confirmed! Showing final movie.');
                        showFinalChoice(movie);
                        return;
                    }
                } catch (error) {
                    console.error('Error checking partner confirmation:', error);
                }

                // Partner hasn't confirmed yet, wait for them
                let confirmationReceived = false;
                const partnerConfirmationRef = database.ref(`sessions/${sessionId}/${partnerConfirmationKey}`);
                const partnerConfirmationCallback = (snapshot) => {
                    const confirmed = snapshot.val();
                    if (confirmed === true && !confirmationReceived) {
                        confirmationReceived = true;
                        const listenerId = sessionManager.get('partnerConfirmationListenerId');
                        if (listenerId) {
                            firebaseManager.removeListener(listenerId);
                            sessionManager.set('partnerConfirmationListenerId', null);
                        }
                        console.log('Partner confirmed! Showing final movie.');
                        showFinalChoice(movie);
                    }
                };

                const listenerId = firebaseManager.addListener(partnerConfirmationRef, 'value', partnerConfirmationCallback);
                sessionManager.set('partnerConfirmationListenerId', listenerId);

                // Add timeout
                setTimeout(() => {
                    if (!confirmationReceived) {
                        confirmationReceived = true;
                        const listenerId = sessionManager.get('partnerConfirmationListenerId');
                        if (listenerId) {
                            firebaseManager.removeListener(listenerId);
                            sessionManager.set('partnerConfirmationListenerId', null);
                        }
                        alert('–í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–∞—Ä—Ç–Ω–µ—Ä–∞ –∏—Å—Ç–µ–∫–ª–æ.');
                        showFinalChoice(movie);
                    }
                }, 2 * 60 * 1000); // 2 minutes for confirmation
            } else {
                // Demo mode
                showFinalChoice(movie);
            }
        }

        function showFinalChoice(movie) {
            console.log('showFinalChoice() - transitioning to FINAL');
            sessionManager.transitionTo(SessionState.FINAL);

            // Clean up all remaining listeners - we're done!
            cleanupAllListeners();

            showScreen('finalScreen');
            const posterContent = movie.poster.startsWith('http')
                ? `<img src="${escapeHtml(movie.poster)}" class="final-poster" alt="${escapeHtml(movie.title)}">`
                : `<div style="font-size: 120px; margin-bottom: 20px;">${movie.poster}</div>`;

            document.getElementById('finalMovie').innerHTML = `
                ${posterContent}
                <h2 style="font-size: 28px; margin-bottom: 15px;">${escapeHtml(movie.title)}</h2>
                <p style="font-size: 16px; opacity: 0.9;">${escapeHtml(movie.overview)}</p>
            `;

            // Trigger confetti animation
            setTimeout(() => playConfetti(), 100);
        }

        // Confetti animation
        function playConfetti() {
            const canvas = document.createElement('canvas');
            canvas.style.position = 'fixed';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '999';
            document.body.appendChild(canvas);

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const ctx = canvas.getContext('2d');
            const confetti = [];
            const colors = ['#667eea', '#764ba2', '#2ed573', '#ff4757', '#ffd700', '#2196f3'];

            // Create confetti particles
            for (let i = 0; i < 150; i++) {
                confetti.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    r: Math.random() * 6 + 4,
                    d: Math.random() * 10 + 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    tilt: Math.random() * 10 - 5,
                    tiltAngleIncremental: Math.random() * 0.07 + 0.05,
                    tiltAngle: 0
                });
            }

            function drawConfetti() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                confetti.forEach((c, index) => {
                    ctx.beginPath();
                    ctx.lineWidth = c.r / 2;
                    ctx.strokeStyle = c.color;
                    ctx.moveTo(c.x + c.tilt + c.r, c.y);
                    ctx.lineTo(c.x + c.tilt, c.y + c.tilt + c.r);
                    ctx.stroke();

                    c.tiltAngle += c.tiltAngleIncremental;
                    c.y += (Math.cos(c.d) + 3 + c.r / 2) / 2;
                    c.x += Math.sin(c.d);
                    c.tilt = Math.sin(c.tiltAngle - index / 3) * 15;

                    if (c.y > canvas.height) {
                        confetti.splice(index, 1);
                    }
                });

                if (confetti.length > 0) {
                    requestAnimationFrame(drawConfetti);
                } else {
                    // Remove canvas when done
                    setTimeout(() => canvas.remove(), 100);
                }
            }

            drawConfetti();
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
            updateSessionCodeDisplay();
        }

        function updateSessionCodeDisplay() {
            if (!sessionId) return;

            // Update all session code displays
            const displays = [
                { element: 'sessionCodeLink', text: 'sessionCodeTextLink' },
                { element: 'sessionCodeDisplay', text: 'sessionCodeText' },
                { element: 'sessionCodeResults', text: 'sessionCodeTextResults' },
                { element: 'sessionCodeFinal', text: 'sessionCodeTextFinal' }
            ];

            displays.forEach(display => {
                const element = document.getElementById(display.element);
                const textElement = document.getElementById(display.text);
                if (element && textElement) {
                    element.style.display = 'block';
                    textElement.textContent = sessionId;
                }
            });
        }

        function generateSessionId() {
            return Math.random().toString(36).substring(2, 10);
        }

        // Toast notification system
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const icons = {
                success: '‚úì',
                error: '‚úó',
                info: '‚Ñπ'
            };

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${escapeHtml(message)}</span>
            `;

            container.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(20px)';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        function copyLink() {
            const link = document.getElementById('sessionLink').textContent;
            navigator.clipboard.writeText(link).then(() => {
                showToast('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!', 'success');
            }).catch(() => {
                showToast('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'error');
            });
        }

        function startOver() {
            location.reload();
        }

        // Movie modal functions
        function showMovieModal(movieId) {
            // Try to find movie in matched movies first (if on results screen), otherwise in all movies
            const movie = matchedMovies.find(m => m.id === movieId) || movies.find(m => m.id === movieId);
            if (!movie) return;

            const modal = document.getElementById('movieModal');
            const modalDetails = document.getElementById('modalMovieDetails');

            // Language badges
            const languageBadges = movie.languages && movie.languages.length > 0
                ? `<div class="modal-languages">
                    ${movie.languages.map(lang => `<span class="modal-language-badge ${lang}">${lang}</span>`).join('')}
                   </div>`
                : '';

            const posterContent = movie.poster.startsWith('http')
                ? `<div class="modal-poster">
                    <img src="${escapeHtml(movie.poster)}" alt="${escapeHtml(movie.title)}">
                    ${languageBadges}
                    ${movie.rating !== 'N/A' ? `<div class="modal-rating">‚≠ê ${escapeHtml(movie.rating)}</div>` : ''}
                   </div>`
                : `<div class="modal-poster" style="display: flex; align-items: center; justify-content: center; font-size: 120px;">${movie.poster}</div>`;

            const genresHtml = movie.movieGenres && movie.movieGenres.length > 0
                ? `<div class="modal-genres">${movie.movieGenres.map(g => `<span class="modal-genre">${escapeHtml(g)}</span>`).join('')}</div>`
                : '';

            const metaHtml = `
                <div class="modal-meta">
                    ${movie.year !== 'N/A' ? `<span>üìÖ ${escapeHtml(movie.year)}</span>` : ''}
                    ${movie.director !== '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω' ? `<span>üé¨ ${escapeHtml(movie.director)}</span>` : ''}
                </div>
            `;

            // Show "Select this movie" button only if we're on results screen and not yet confirmed
            const showSelectButton = matchedMovies.length > 0 && !isConfirmed;

            modalDetails.innerHTML = `
                ${posterContent}
                <div class="modal-body">
                    <div class="modal-title">${escapeHtml(movie.title)}</div>
                    ${metaHtml}
                    ${genresHtml}
                    <div class="modal-description">${escapeHtml(movie.overview)}</div>
                    ${showSelectButton ? `<button class="btn" onclick="selectMovieFromModal(${movie.id})">–í—ã–±—Ä–∞—Ç—å —ç—Ç–æ—Ç —Ñ–∏–ª—å–º</button>` : ''}
                </div>
            `;

            modal.classList.add('active');
        }

        function closeMovieModal(event) {
            // Close only if clicking on overlay or explicit close
            if (!event || event.target.id === 'movieModal' || event.target.classList.contains('modal-close')) {
                document.getElementById('movieModal').classList.remove('active');
            }
        }

        function selectMovieFromModal(movieId) {
            closeMovieModal();
            toggleMovieSelection(movieId);
        }

        // Initialize app
        document.getElementById('createSessionBtn').onclick = createSession;

        // Check if joining session
        const urlParams = new URLSearchParams(window.location.search);
        const sessionParam = urlParams.get('session');

        if (sessionParam) {
            sessionId = sessionParam;
            console.log('Joining session from URL:', sessionId);

            // Wait for Firebase to initialize before joining
            (async () => {
                try {
                    console.log('Waiting for Firebase to initialize...');
                    await waitForFirebase();
                    console.log('Firebase ready, joining session');
                    await joinSession(sessionId);
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                    alert('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Firebase: ' + error.message + '\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.');
                    window.location.href = window.location.pathname;
                }
            })();
        } else {
            initializeUI();
        }
    </script>
</body>
</html>
